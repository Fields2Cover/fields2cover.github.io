

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File assertions.md &mdash; Fields2Cover latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../_static/code-tabs.css?v=1bc26e2f" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://fields2cover.github.io/api/program_listing_file_googletest_docs_reference_assertions.md.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/code-tabs.js?v=c983d12e"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo_fields2cover.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Fields2Cover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/migration_to_v2.html">Migration guide to version 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="f2c_library.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Fields2Cover</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File assertions.md</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_googletest_docs_reference_assertions.md.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-assertions-md">
<span id="program-listing-file-googletest-docs-reference-assertions-md"></span><h1>Program Listing for File assertions.md<a class="headerlink" href="#program-listing-for-file-assertions-md" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_googletest_docs_reference_assertions.md.html#file-googletest-docs-reference-assertions-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">googletest/docs/reference/assertions.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span><span class="gh"># Assertions Reference</span>

This page lists the assertion macros provided by GoogleTest for verifying code
behavior. To use them, add <span class="sb">`#include &lt;gtest/gtest.h&gt;`</span>.

The majority of the macros listed below come as a pair with an <span class="sb">`EXPECT_`</span> variant
and an <span class="sb">`ASSERT_`</span> variant. Upon failure, <span class="sb">`EXPECT_`</span> macros generate nonfatal
failures and allow the current function to continue running, while <span class="sb">`ASSERT_`</span>
macros generate fatal failures and abort the current function.

All assertion macros support streaming a custom failure message into them with
the <span class="sb">`&lt;&lt;`</span> operator, for example:

<span class="sb">```cpp</span>
<span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">my_condition</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;My condition is not true&quot;</span><span class="p">;</span>
<span class="sb">```</span>

Anything that can be streamed to an <span class="sb">`ostream`</span> can be streamed to an assertion
macro—in particular, C strings and string objects. If a wide string (<span class="sb">`wchar_t*`</span>,
<span class="sb">`TCHAR*`</span> in <span class="sb">`UNICODE`</span> mode on Windows, or <span class="sb">`std::wstring`</span>) is streamed to an
assertion, it will be translated to UTF-8 when printed.

<span class="gu">## Explicit Success and Failure {#success-failure}</span>

The assertions in this section generate a success or failure directly instead of
testing a value or expression. These are useful when control flow, rather than a
Boolean expression, determines the test&#39;s success or failure, as shown by the
following example:

```c++
switch(expression) {
  case 1:
    ... some checks ...
  case 2:
    ... some other checks ...
  default:
    FAIL() &lt;&lt; &quot;We shouldn&#39;t get here.&quot;;
}
<span class="sb">```</span>

<span class="sb">### SUCCEED {#SUCCEED}</span>

<span class="sb">`SUCCEED()`</span>

<span class="sb">Generates a success. This *does not* make the overall test succeed. A test is</span>
<span class="sb">considered successful only if none of its assertions fail during its execution.</span>

<span class="sb">The `SUCCEED` assertion is purely documentary and currently doesn&#39;t generate any</span>
<span class="sb">user-visible output. However, we may add `SUCCEED` messages to GoogleTest output</span>
<span class="sb">in the future.</span>

<span class="sb">### FAIL {#FAIL}</span>

<span class="sb">`FAIL()`</span>

<span class="sb">Generates a fatal failure, which returns from the current function.</span>

<span class="sb">Can only be used in functions that return `void`. See</span>
<span class="sb">[Assertion Placement](../advanced.md#assertion-placement) for more information.</span>

<span class="sb">### ADD_FAILURE {#ADD_FAILURE}</span>

<span class="sb">`ADD_FAILURE()`</span>

<span class="sb">Generates a nonfatal failure, which allows the current function to continue</span>
<span class="sb">running.</span>

<span class="sb">### ADD_FAILURE_AT {#ADD_FAILURE_AT}</span>

<span class="sb">`ADD_FAILURE_AT(`*`file_path`*`,`*`line_number`*`)`</span>

<span class="sb">Generates a nonfatal failure at the file and line number specified.</span>

<span class="sb">## Generalized Assertion {#generalized}</span>

<span class="sb">The following assertion allows [matchers](matchers.md) to be used to verify</span>
<span class="sb">values.</span>

<span class="sb">### EXPECT_THAT {#EXPECT_THAT}</span>

<span class="sb">`EXPECT_THAT(`*`value`*`,`*`matcher`*`)` \</span>
<span class="sb">`ASSERT_THAT(`*`value`*`,`*`matcher`*`)`</span>

<span class="sb">Verifies that *`value`* matches the [matcher](matchers.md) *`matcher`*.</span>

<span class="sb">For example, the following code verifies that the string `value1` starts with</span>
<span class="sb">`&quot;Hello&quot;`, `value2` matches a regular expression, and `value3` is between 5 and</span>
<span class="sb">10:</span>

<span class="sb">```cpp</span>
<span class="sb">#include &lt;gmock/gmock.h&gt;</span>

<span class="sb">using ::testing::AllOf;</span>
<span class="sb">using ::testing::Gt;</span>
<span class="sb">using ::testing::Lt;</span>
<span class="sb">using ::testing::MatchesRegex;</span>
<span class="sb">using ::testing::StartsWith;</span>

<span class="sb">...</span>
<span class="sb">EXPECT_THAT(value1, StartsWith(&quot;Hello&quot;));</span>
<span class="sb">EXPECT_THAT(value2, MatchesRegex(&quot;Line \\d+&quot;));</span>
<span class="sb">ASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));</span>
<span class="sb">```</span>

Matchers enable assertions of this form to read like English and generate
informative failure messages. For example, if the above assertion on <span class="sb">`value1`</span>
fails, the resulting message will be similar to the following:

<span class="sb">```</span>
<span class="sb">Value of: value1</span>
<span class="sb">  Actual: &quot;Hi, world!&quot;</span>
<span class="sb">Expected: starts with &quot;Hello&quot;</span>
<span class="sb">```</span>

GoogleTest provides a built-in library of matchers—see the
[<span class="nt">Matchers Reference</span>](<span class="na">matchers.md</span>). It is also possible to write your own
matchers—see [<span class="nt">Writing New Matchers Quickly</span>](<span class="na">../gmock_cook_book.md#NewMatchers</span>).
The use of matchers makes <span class="sb">`EXPECT_THAT`</span> a powerful, extensible assertion.

*The idea for this assertion was borrowed from Joe Walnes&#39; Hamcrest project,
which adds <span class="sb">`assertThat()`</span> to JUnit.*

<span class="gu">## Boolean Conditions {#boolean}</span>

The following assertions test Boolean conditions.

<span class="gu">### EXPECT_TRUE {#EXPECT_TRUE}</span>

<span class="sb">`EXPECT_TRUE(`</span>*<span class="sb">`condition`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_TRUE(`</span>*<span class="sb">`condition`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`condition`*</span> is true.

<span class="gu">### EXPECT_FALSE {#EXPECT_FALSE}</span>

<span class="sb">`EXPECT_FALSE(`</span>*<span class="sb">`condition`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_FALSE(`</span>*<span class="sb">`condition`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`condition`*</span> is false.

<span class="gu">## Binary Comparison {#binary-comparison}</span>

The following assertions compare two values. The value arguments must be
comparable by the assertion&#39;s comparison operator, otherwise a compiler error
will result.

If an argument supports the <span class="sb">`&lt;&lt;`</span> operator, it will be called to print the
argument when the assertion fails. Otherwise, GoogleTest will attempt to print
them in the best way it can—see
[<span class="nt">Teaching GoogleTest How to Print Your Values</span>](<span class="na">../advanced.md#teaching-googletest-how-to-print-your-values</span>).

Arguments are always evaluated exactly once, so it&#39;s OK for the arguments to
have side effects. However, the argument evaluation order is undefined and
programs should not depend on any particular argument evaluation order.

These assertions work with both narrow and wide string objects (<span class="sb">`string`</span> and
<span class="sb">`wstring`</span>).

See also the [<span class="nt">Floating-Point Comparison</span>](<span class="na">#floating-point</span>) assertions to compare
floating-point numbers and avoid problems caused by rounding.

<span class="gu">### EXPECT_EQ {#EXPECT_EQ}</span>

<span class="sb">`EXPECT_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`==`</span>*<span class="sb">`val2`</span>*.

Does pointer equality on pointers. If used on two C strings, it tests if they
are in the same memory location, not if they have the same value. Use
[<span class="sb">`EXPECT_STREQ`</span>](#EXPECT_STREQ) to compare C strings (e.g. <span class="sb">`const char*`</span>) by
value.

When comparing a pointer to <span class="sb">`NULL`</span>, use <span class="sb">`EXPECT_EQ(`</span>*<span class="sb">`ptr`</span>*<span class="sb">`, nullptr)`</span> instead
of <span class="sb">`EXPECT_EQ(`</span>*<span class="sb">`ptr`</span>*<span class="sb">`, NULL)`</span>.

<span class="gu">### EXPECT_NE {#EXPECT_NE}</span>

<span class="sb">`EXPECT_NE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_NE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`!=`</span>*<span class="sb">`val2`</span>*.

Does pointer equality on pointers. If used on two C strings, it tests if they
are in different memory locations, not if they have different values. Use
[<span class="sb">`EXPECT_STRNE`</span>](#EXPECT_STRNE) to compare C strings (e.g. <span class="sb">`const char*`</span>) by
value.

When comparing a pointer to <span class="sb">`NULL`</span>, use <span class="sb">`EXPECT_NE(`</span>*<span class="sb">`ptr`</span>*<span class="sb">`, nullptr)`</span> instead
of <span class="sb">`EXPECT_NE(`</span>*<span class="sb">`ptr`</span>*<span class="sb">`, NULL)`</span>.

<span class="gu">### EXPECT_LT {#EXPECT_LT}</span>

<span class="sb">`EXPECT_LT(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_LT(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`&lt;`</span>*<span class="sb">`val2`</span>*.

<span class="gu">### EXPECT_LE {#EXPECT_LE}</span>

<span class="sb">`EXPECT_LE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_LE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`&lt;=`</span>*<span class="sb">`val2`</span>*.

<span class="gu">### EXPECT_GT {#EXPECT_GT}</span>

<span class="sb">`EXPECT_GT(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_GT(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`&gt;`</span>*<span class="sb">`val2`</span>*.

<span class="gu">### EXPECT_GE {#EXPECT_GE}</span>

<span class="sb">`EXPECT_GE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_GE(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`val1`*</span><span class="sb">`&gt;=`</span>*<span class="sb">`val2`</span>*.

<span class="gu">## String Comparison {#c-strings}</span>

The following assertions compare two <span class="gs">**C strings**</span>. To compare two <span class="sb">`string`</span>
objects, use [<span class="sb">`EXPECT_EQ`</span>](#EXPECT_EQ) or [<span class="sb">`EXPECT_NE`</span>](#EXPECT_NE) instead.

These assertions also accept wide C strings (<span class="sb">`wchar_t*`</span>). If a comparison of two
wide strings fails, their values will be printed as UTF-8 narrow strings.

To compare a C string with <span class="sb">`NULL`</span>, use <span class="sb">`EXPECT_EQ(`</span>*<span class="sb">`c_string`</span>*<span class="sb">`, nullptr)`</span> or
<span class="sb">`EXPECT_NE(`</span>*<span class="sb">`c_string`</span>*<span class="sb">`, nullptr)`</span>.

<span class="gu">### EXPECT_STREQ {#EXPECT_STREQ}</span>

<span class="sb">`EXPECT_STREQ(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_STREQ(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span>

Verifies that the two C strings <span class="ge">*`str1`*</span> and <span class="ge">*`str2`*</span> have the same contents.

<span class="gu">### EXPECT_STRNE {#EXPECT_STRNE}</span>

<span class="sb">`EXPECT_STRNE(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_STRNE(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span>

Verifies that the two C strings <span class="ge">*`str1`*</span> and <span class="ge">*`str2`*</span> have different contents.

<span class="gu">### EXPECT_STRCASEEQ {#EXPECT_STRCASEEQ}</span>

<span class="sb">`EXPECT_STRCASEEQ(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_STRCASEEQ(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span>

Verifies that the two C strings <span class="ge">*`str1`*</span> and <span class="ge">*`str2`*</span> have the same contents,
ignoring case.

<span class="gu">### EXPECT_STRCASENE {#EXPECT_STRCASENE}</span>

<span class="sb">`EXPECT_STRCASENE(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_STRCASENE(`</span>*<span class="sb">`str1`</span>*<span class="sb">`,`</span>*<span class="sb">`str2`</span>*<span class="sb">`)`</span>

Verifies that the two C strings <span class="ge">*`str1`*</span> and <span class="ge">*`str2`*</span> have different contents,
ignoring case.

<span class="gu">## Floating-Point Comparison {#floating-point}</span>

The following assertions compare two floating-point values.

Due to rounding errors, it is very unlikely that two floating-point values will
match exactly, so <span class="sb">`EXPECT_EQ`</span> is not suitable. In general, for floating-point
comparison to make sense, the user needs to carefully choose the error bound.

GoogleTest also provides assertions that use a default error bound based on
Units in the Last Place (ULPs). To learn more about ULPs, see the article
[<span class="nt">Comparing Floating Point Numbers</span>](<span class="na">https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</span>).

<span class="gu">### EXPECT_FLOAT_EQ {#EXPECT_FLOAT_EQ}</span>

<span class="sb">`EXPECT_FLOAT_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_FLOAT_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that the two <span class="sb">`float`</span> values <span class="ge">*`val1`*</span> and <span class="ge">*`val2`*</span> are approximately
equal, to within 4 ULPs from each other. Infinity and the largest finite float
value are considered to be one ULP apart.

<span class="gu">### EXPECT_DOUBLE_EQ {#EXPECT_DOUBLE_EQ}</span>

<span class="sb">`EXPECT_DOUBLE_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_DOUBLE_EQ(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span>

Verifies that the two <span class="sb">`double`</span> values <span class="ge">*`val1`*</span> and <span class="ge">*`val2`*</span> are approximately
equal, to within 4 ULPs from each other. Infinity and the largest finite double
value are considered to be one ULP apart.

<span class="gu">### EXPECT_NEAR {#EXPECT_NEAR}</span>

<span class="sb">`EXPECT_NEAR(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`abs_error`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_NEAR(`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`abs_error`</span>*<span class="sb">`)`</span>

Verifies that the difference between <span class="ge">*`val1`*</span> and <span class="ge">*`val2`*</span> does not exceed the
absolute error bound <span class="ge">*`abs_error`*</span>.

If <span class="ge">*`val`*</span> and <span class="ge">*`val2`*</span> are both infinity of the same sign, the difference is
considered to be 0. Otherwise, if either value is infinity, the difference is
considered to be infinity. All non-NaN values (including infinity) are
considered to not exceed an <span class="ge">*`abs_error`*</span> of infinity.

<span class="gu">## Exception Assertions {#exceptions}</span>

The following assertions verify that a piece of code throws, or does not throw,
an exception. Usage requires exceptions to be enabled in the build environment.

Note that the piece of code under test can be a compound statement, for example:

<span class="sb">```cpp</span>
<span class="n">EXPECT_NO_THROW</span><span class="p">({</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">DoSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">});</span>
<span class="sb">```</span>

<span class="gu">### EXPECT_THROW {#EXPECT_THROW}</span>

<span class="sb">`EXPECT_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`exception_type`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`exception_type`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`statement`*</span> throws an exception of type <span class="ge">*`exception_type`*</span>.

<span class="gu">### EXPECT_ANY_THROW {#EXPECT_ANY_THROW}</span>

<span class="sb">`EXPECT_ANY_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_ANY_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`statement`*</span> throws an exception of any type.

<span class="gu">### EXPECT_NO_THROW {#EXPECT_NO_THROW}</span>

<span class="sb">`EXPECT_NO_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_NO_THROW(`</span>*<span class="sb">`statement`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`statement`*</span> does not throw any exception.

<span class="gu">## Predicate Assertions {#predicates}</span>

The following assertions enable more complex predicates to be verified while
printing a more clear failure message than if <span class="sb">`EXPECT_TRUE`</span> were used alone.

<span class="gu">### EXPECT_PRED* {#EXPECT_PRED}</span>

<span class="sb">`EXPECT_PRED1(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED2(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED3(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED4(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED5(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`,`</span>*<span class="sb">`val5`</span>*<span class="sb">`)`</span>

<span class="sb">`ASSERT_PRED1(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED2(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED3(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED4(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED5(`</span>*<span class="sb">`pred`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`,`</span>*<span class="sb">`val5`</span>*<span class="sb">`)`</span>

Verifies that the predicate <span class="ge">*`pred`*</span> returns <span class="sb">`true`</span> when passed the given values
as arguments.

The parameter <span class="ge">*`pred`*</span> is a function or functor that accepts as many arguments
as the corresponding macro accepts values. If <span class="ge">*`pred`*</span> returns <span class="sb">`true`</span> for the
given arguments, the assertion succeeds, otherwise the assertion fails.

When the assertion fails, it prints the value of each argument. Arguments are
always evaluated exactly once.

As an example, see the following code:

<span class="sb">```cpp</span>
<span class="c1">// Returns true if m and n have no common divisors except 1.</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">MutuallyPrime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_PRED2</span><span class="p">(</span><span class="n">MutuallyPrime</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// Succeeds</span>
<span class="n">EXPECT_PRED2</span><span class="p">(</span><span class="n">MutuallyPrime</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">  </span><span class="c1">// Fails</span>
<span class="sb">```</span>

In the above example, the first assertion succeeds, and the second fails with
the following message:

<span class="sb">```</span>
<span class="sb">MutuallyPrime(b, c) is false, where</span>
<span class="sb">b is 4</span>
<span class="sb">c is 10</span>
<span class="sb">```</span>

Note that if the given predicate is an overloaded function or a function
template, the assertion macro might not be able to determine which version to
use, and it might be necessary to explicitly specify the type of the function.
For example, for a Boolean function <span class="sb">`IsPositive()`</span> overloaded to take either a
single <span class="sb">`int`</span> or <span class="sb">`double`</span> argument, it would be necessary to write one of the
following:

<span class="sb">```cpp</span>
<span class="n">EXPECT_PRED1</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IsPositive</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="n">EXPECT_PRED1</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IsPositive</span><span class="p">),</span><span class="w"> </span><span class="mf">3.14</span><span class="p">);</span>
<span class="sb">```</span>

Writing simply <span class="sb">`EXPECT_PRED1(IsPositive, 5);`</span> would result in a compiler error.
Similarly, to use a template function, specify the template arguments:

<span class="sb">```cpp</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">IsNegative</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">EXPECT_PRED1</span><span class="p">(</span><span class="n">IsNegative</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">-5</span><span class="p">);</span><span class="w">  </span><span class="c1">// Must specify type for IsNegative</span>
<span class="sb">```</span>

If a template has multiple parameters, wrap the predicate in parentheses so the
macro arguments are parsed correctly:

<span class="sb">```cpp</span>
<span class="n">ASSERT_PRED2</span><span class="p">((</span><span class="n">MyPredicate</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="sb">```</span>

<span class="gu">### EXPECT_PRED_FORMAT* {#EXPECT_PRED_FORMAT}</span>

<span class="sb">`EXPECT_PRED_FORMAT1(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED_FORMAT2(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED_FORMAT3(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`)`</span> \
<span class="sb">`EXPECT_PRED_FORMAT4(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`)`</span>
\
<span class="sb">`EXPECT_PRED_FORMAT5(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`,`</span>*<span class="sb">`val5`</span>*<span class="sb">`)`</span>

<span class="sb">`ASSERT_PRED_FORMAT1(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED_FORMAT2(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED_FORMAT3(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_PRED_FORMAT4(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`)`</span>
\
<span class="sb">`ASSERT_PRED_FORMAT5(`</span>*<span class="sb">`pred_formatter`</span>*<span class="sb">`,`</span>*<span class="sb">`val1`</span>*<span class="sb">`,`</span>*<span class="sb">`val2`</span>*<span class="sb">`,`</span>*<span class="sb">`val3`</span>*<span class="sb">`,`</span>*<span class="sb">`val4`</span>*<span class="sb">`,`</span>*<span class="sb">`val5`</span>*<span class="sb">`)`</span>

Verifies that the predicate <span class="ge">*`pred_formatter`*</span> succeeds when passed the given
values as arguments.

The parameter <span class="ge">*`pred_formatter`*</span> is a <span class="ge">*predicate-formatter*</span>, which is a function
or functor with the signature:

<span class="sb">```cpp</span>
<span class="n">testing</span><span class="o">::</span><span class="n">AssertionResult</span><span class="w"> </span><span class="nf">PredicateFormatter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">expr1</span><span class="p">,</span>
<span class="w">                                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">expr2</span><span class="p">,</span>
<span class="w">                                            </span><span class="p">...</span>
<span class="w">                                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">exprn</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">T1</span><span class="w"> </span><span class="n">val1</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">T2</span><span class="w"> </span><span class="n">val2</span><span class="p">,</span>
<span class="w">                                            </span><span class="p">...</span>
<span class="w">                                            </span><span class="n">Tn</span><span class="w"> </span><span class="n">valn</span><span class="p">);</span>
<span class="sb">```</span>

where <span class="ge">*`val1`*</span>, <span class="ge">*`val2`*</span>, ..., <span class="ge">*`valn`*</span> are the values of the predicate
arguments, and <span class="ge">*`expr1`*</span>, <span class="ge">*`expr2`*</span>, ..., <span class="ge">*`exprn`*</span> are the corresponding
expressions as they appear in the source code. The types <span class="sb">`T1`</span>, <span class="sb">`T2`</span>, ..., <span class="sb">`Tn`</span>
can be either value types or reference types; if an argument has type <span class="sb">`T`</span>, it
can be declared as either <span class="sb">`T`</span> or <span class="sb">`const T&amp;`</span>, whichever is appropriate. For more
about the return type <span class="sb">`testing::AssertionResult`</span>, see
[<span class="nt">Using a Function That Returns an AssertionResult</span>](<span class="na">../advanced.md#using-a-function-that-returns-an-assertionresult</span>).

As an example, see the following code:

<span class="sb">```cpp</span>
<span class="c1">// Returns the smallest prime common divisor of m and n,</span>
<span class="c1">// or 1 when m and n are mutually prime.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">SmallestPrimeCommonDivisor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Returns true if m and n have no common divisors except 1.</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">MutuallyPrime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// A predicate-formatter for asserting that two integers are mutually prime.</span>
<span class="n">testing</span><span class="o">::</span><span class="n">AssertionResult</span><span class="w"> </span><span class="nf">AssertMutuallyPrime</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">m_expr</span><span class="p">,</span>
<span class="w">                                             </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">n_expr</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MutuallyPrime</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionSuccess</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionFailure</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m_expr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n_expr</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;) are not mutually prime, &quot;</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;as they have a common divisor &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SmallestPrimeCommonDivisor</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_PRED_FORMAT2</span><span class="p">(</span><span class="n">AssertMutuallyPrime</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// Succeeds</span>
<span class="n">EXPECT_PRED_FORMAT2</span><span class="p">(</span><span class="n">AssertMutuallyPrime</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">  </span><span class="c1">// Fails</span>
<span class="sb">```</span>

In the above example, the final assertion fails and the predicate-formatter
produces the following failure message:

<span class="sb">```</span>
<span class="sb">b and c (4 and 10) are not mutually prime, as they have a common divisor 2</span>
<span class="sb">```</span>

<span class="gu">## Windows HRESULT Assertions {#HRESULT}</span>

The following assertions test for <span class="sb">`HRESULT`</span> success or failure. For example:

<span class="sb">```cpp</span>
<span class="n">CComPtr</span><span class="o">&lt;</span><span class="n">IShellDispatch2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shell</span><span class="p">;</span>
<span class="n">ASSERT_HRESULT_SUCCEEDED</span><span class="p">(</span><span class="n">shell</span><span class="p">.</span><span class="n">CoCreateInstance</span><span class="p">(</span><span class="sa">L</span><span class="s">&quot;Shell.Application&quot;</span><span class="p">));</span>
<span class="n">CComVariant</span><span class="w"> </span><span class="n">empty</span><span class="p">;</span>
<span class="n">ASSERT_HRESULT_SUCCEEDED</span><span class="p">(</span><span class="n">shell</span><span class="o">-&gt;</span><span class="n">ShellExecute</span><span class="p">(</span><span class="n">CComBSTR</span><span class="p">(</span><span class="n">url</span><span class="p">),</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">));</span>
<span class="sb">```</span>

The generated output contains the human-readable error message associated with
the returned <span class="sb">`HRESULT`</span> code.

<span class="gu">### EXPECT_HRESULT_SUCCEEDED {#EXPECT_HRESULT_SUCCEEDED}</span>

<span class="sb">`EXPECT_HRESULT_SUCCEEDED(`</span>*<span class="sb">`expression`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_HRESULT_SUCCEEDED(`</span>*<span class="sb">`expression`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`expression`*</span> is a success <span class="sb">`HRESULT`</span>.

<span class="gu">### EXPECT_HRESULT_FAILED {#EXPECT_HRESULT_FAILED}</span>

<span class="sb">`EXPECT_HRESULT_FAILED(`</span>*<span class="sb">`expression`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_HRESULT_FAILED(`</span>*<span class="sb">`expression`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`expression`*</span> is a failure <span class="sb">`HRESULT`</span>.

<span class="gu">## Death Assertions {#death}</span>

The following assertions verify that a piece of code causes the process to
terminate. For context, see [<span class="nt">Death Tests</span>](<span class="na">../advanced.md#death-tests</span>).

These assertions spawn a new process and execute the code under test in that
process. How that happens depends on the platform and the variable
<span class="sb">`::testing::GTEST_FLAG(death_test_style)`</span>, which is initialized from the
command-line flag <span class="sb">`--gtest_death_test_style`</span>.

<span class="k">*</span><span class="w"> </span>  On POSIX systems, <span class="sb">`fork()`</span> (or <span class="sb">`clone()`</span> on Linux) is used to spawn the
    child, after which:
<span class="w">    </span><span class="k">*</span><span class="w"> </span>  If the variable&#39;s value is <span class="sb">`&quot;fast&quot;`</span>, the death test statement is
        immediately executed.
<span class="w">    </span><span class="k">*</span><span class="w"> </span>  If the variable&#39;s value is <span class="sb">`&quot;threadsafe&quot;`</span>, the child process re-executes
        the unit test binary just as it was originally invoked, but with some
        extra flags to cause just the single death test under consideration to
        be run.
<span class="k">*</span><span class="w"> </span>  On Windows, the child is spawned using the <span class="sb">`CreateProcess()`</span> API, and
    re-executes the binary to cause just the single death test under
    consideration to be run - much like the <span class="sb">`&quot;threadsafe&quot;`</span> mode on POSIX.

Other values for the variable are illegal and will cause the death test to fail.
Currently, the flag&#39;s default value is
<span class="gs">**`&quot;fast&quot;`**</span>.

If the death test statement runs to completion without dying, the child process
will nonetheless terminate, and the assertion fails.

Note that the piece of code under test can be a compound statement, for example:

<span class="sb">```cpp</span>
<span class="n">EXPECT_DEATH</span><span class="p">({</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">DoSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="s">&quot;Error on line .* of DoSomething()&quot;</span><span class="p">);</span>
<span class="sb">```</span>

<span class="gu">### EXPECT_DEATH {#EXPECT_DEATH}</span>

<span class="sb">`EXPECT_DEATH(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_DEATH(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`statement`*</span> causes the process to terminate with a nonzero exit
status and produces <span class="sb">`stderr`</span> output that matches <span class="ge">*`matcher`*</span>.

The parameter <span class="ge">*`matcher`*</span> is either a [<span class="nt">matcher</span>](<span class="na">matchers.md</span>) for a `const
std::string&amp;`, or a regular expression (see
[<span class="nt">Regular Expression Syntax</span>](<span class="na">../advanced.md#regular-expression-syntax</span>))—a bare
string <span class="ge">*`s`*</span> (with no matcher) is treated as
[<span class="sb">`ContainsRegex(s)`</span>](matchers.md#string-matchers), <span class="gs">**not**</span>
[<span class="sb">`Eq(s)`</span>](matchers.md#generic-comparison).

For example, the following code verifies that calling <span class="sb">`DoSomething(42)`</span> causes
the process to die with an error message that contains the text <span class="sb">`My error`</span>:

<span class="sb">```cpp</span>
<span class="n">EXPECT_DEATH</span><span class="p">(</span><span class="n">DoSomething</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;My error&quot;</span><span class="p">);</span>
<span class="sb">```</span>

<span class="gu">### EXPECT_DEATH_IF_SUPPORTED {#EXPECT_DEATH_IF_SUPPORTED}</span>

<span class="sb">`EXPECT_DEATH_IF_SUPPORTED(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_DEATH_IF_SUPPORTED(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span>

If death tests are supported, behaves the same as
[<span class="sb">`EXPECT_DEATH`</span>](#EXPECT_DEATH). Otherwise, verifies nothing.

<span class="gu">### EXPECT_DEBUG_DEATH {#EXPECT_DEBUG_DEATH}</span>

<span class="sb">`EXPECT_DEBUG_DEATH(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_DEBUG_DEATH(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span>

In debug mode, behaves the same as [<span class="sb">`EXPECT_DEATH`</span>](#EXPECT_DEATH). When not in
debug mode (i.e. <span class="sb">`NDEBUG`</span> is defined), just executes <span class="ge">*`statement`*</span>.

<span class="gu">### EXPECT_EXIT {#EXPECT_EXIT}</span>

<span class="sb">`EXPECT_EXIT(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`predicate`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span> \
<span class="sb">`ASSERT_EXIT(`</span>*<span class="sb">`statement`</span>*<span class="sb">`,`</span>*<span class="sb">`predicate`</span>*<span class="sb">`,`</span>*<span class="sb">`matcher`</span>*<span class="sb">`)`</span>

Verifies that <span class="ge">*`statement`*</span> causes the process to terminate with an exit status
that satisfies <span class="ge">*`predicate`*</span>, and produces <span class="sb">`stderr`</span> output that matches
<span class="ge">*`matcher`*</span>.

The parameter <span class="ge">*`predicate`*</span> is a function or functor that accepts an <span class="sb">`int`</span> exit
status and returns a <span class="sb">`bool`</span>. GoogleTest provides two predicates to handle common
cases:

<span class="sb">```cpp</span>
<span class="c1">// Returns true if the program exited normally with the given exit status code.</span>
<span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ExitedWithCode</span><span class="p">(</span><span class="n">exit_code</span><span class="p">);</span>

<span class="c1">// Returns true if the program was killed by the given signal.</span>
<span class="c1">// Not available on Windows.</span>
<span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">KilledBySignal</span><span class="p">(</span><span class="n">signal_number</span><span class="p">);</span>
<span class="sb">```</span>

The parameter <span class="ge">*`matcher`*</span> is either a [<span class="nt">matcher</span>](<span class="na">matchers.md</span>) for a `const
std::string&amp;`, or a regular expression (see
[<span class="nt">Regular Expression Syntax</span>](<span class="na">../advanced.md#regular-expression-syntax</span>))—a bare
string <span class="ge">*`s`*</span> (with no matcher) is treated as
[<span class="sb">`ContainsRegex(s)`</span>](matchers.md#string-matchers), <span class="gs">**not**</span>
[<span class="sb">`Eq(s)`</span>](matchers.md#generic-comparison).

For example, the following code verifies that calling <span class="sb">`NormalExit()`</span> causes the
process to print a message containing the text <span class="sb">`Success`</span> to <span class="sb">`stderr`</span> and exit
with exit status code 0:

<span class="sb">```cpp</span>
<span class="n">EXPECT_EXIT</span><span class="p">(</span><span class="n">NormalExit</span><span class="p">(),</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">ExitedWithCode</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Success&quot;</span><span class="p">);</span>
<span class="sb">```</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2024, Wageningen University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #D0F1C6; */
    }
    /* Sidebar */
    .wy-nav-side {
      /* background: #ff0000; */
    }
  </style>


</body>
</html>