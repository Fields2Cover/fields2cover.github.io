

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File gtest-internal-inl.h &mdash; Fields2Cover latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../_static/code-tabs.css?v=1bc26e2f" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://fields2cover.github.io/api/program_listing_file_googletest_googletest_src_gtest-internal-inl.h.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/code-tabs.js?v=c983d12e"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo_fields2cover.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Fields2Cover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/migration_to_v2.html">Migration guide to version 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="f2c_library.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Fields2Cover</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File gtest-internal-inl.h</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_googletest_googletest_src_gtest-internal-inl.h.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-gtest-internal-inl-h">
<span id="program-listing-file-googletest-googletest-src-gtest-internal-inl-h"></span><h1>Program Listing for File gtest-internal-inl.h<a class="headerlink" href="#program-listing-for-file-gtest-internal-inl-h" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_googletest_googletest_src_gtest-internal-inl.h.html#file-googletest-googletest-src-gtest-internal-inl-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">googletest/googletest/src/gtest-internal-inl.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copyright 2005, Google Inc.</span>
<span class="c1">// All rights reserved.</span>
<span class="c1">//</span>
<span class="c1">// Redistribution and use in source and binary forms, with or without</span>
<span class="c1">// modification, are permitted provided that the following conditions are</span>
<span class="c1">// met:</span>
<span class="c1">//</span>
<span class="c1">//     * Redistributions of source code must retain the above copyright</span>
<span class="c1">// notice, this list of conditions and the following disclaimer.</span>
<span class="c1">//     * Redistributions in binary form must reproduce the above</span>
<span class="c1">// copyright notice, this list of conditions and the following disclaimer</span>
<span class="c1">// in the documentation and/or other materials provided with the</span>
<span class="c1">// distribution.</span>
<span class="c1">//     * Neither the name of Google Inc. nor the names of its</span>
<span class="c1">// contributors may be used to endorse or promote products derived from</span>
<span class="c1">// this software without specific prior written permission.</span>
<span class="c1">//</span>
<span class="c1">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="c1">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="c1">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c1">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="c1">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="c1">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c1">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="c1">// Utility functions and classes used by the Google C++ testing framework.//</span>
<span class="c1">// This file contains purely Google Test&#39;s internal implementation.  Please</span>
<span class="c1">// DO NOT #INCLUDE IT IN A USER PROGRAM.</span>

<span class="cp">#ifndef GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_</span>
<span class="cp">#define GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_</span>

<span class="cp">#ifndef _WIN32_WCE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>
<span class="cp">#endif  </span><span class="c1">// !_WIN32_WCE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="c1">  // For strtoll/_strtoul64/malloc/free.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="c1">  // For memmove.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdint&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gtest/internal/gtest-port.h&quot;</span>

<span class="cp">#if GTEST_CAN_STREAM_RESULTS_</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="c1">  // NOLINT</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;netdb.h&gt;</span><span class="c1">      // NOLINT</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef GTEST_OS_WINDOWS</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;windows.h&gt;</span><span class="c1">  // NOLINT</span>
<span class="cp">#endif                </span><span class="c1">// GTEST_OS_WINDOWS</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gtest/gtest-spi.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gtest/gtest.h&quot;</span>

<span class="n">GTEST_DISABLE_MSC_WARNINGS_PUSH_</span><span class="p">(</span><span class="mi">4251</span><span class="w"> </span>\
<span class="cm">/* class A needs to have dll-interface to be used by clients of class B */</span><span class="p">)</span>

<span class="c1">// Declares the flags.</span>
<span class="c1">//</span>
<span class="c1">// We don&#39;t want the users to modify this flag in the code, but want</span>
<span class="c1">// Google Test&#39;s own unit tests to be able to access it. Therefore we</span>
<span class="c1">// declare it here as opposed to in gtest.h.</span>
<span class="n">GTEST_DECLARE_bool_</span><span class="p">(</span><span class="n">death_test_use_fork</span><span class="p">);</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">testing</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">internal</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// The value of GetTestTypeId() as seen from within the Google Test</span>
<span class="c1">// library.  This is solely for testing GetTestTypeId().</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">kTestTypeIdInGoogleTest</span><span class="p">;</span>

<span class="c1">// A valid random seed must be in [1, kMaxRandomSeed].</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kMaxRandomSeed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99999</span><span class="p">;</span>

<span class="c1">// g_help_flag is true if and only if the --help flag or an equivalent form</span>
<span class="c1">// is specified on the command line.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">g_help_flag</span><span class="p">;</span>

<span class="c1">// Returns the current time in milliseconds.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">TimeInMillis</span><span class="w"> </span><span class="n">GetTimeInMillis</span><span class="p">();</span>

<span class="c1">// Returns true if and only if Google Test should use colors in the output.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ShouldUseColor</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">stdout_is_tty</span><span class="p">);</span>

<span class="c1">// Formats the given time in milliseconds as seconds. If the input is an exact N</span>
<span class="c1">// seconds, the output has a trailing decimal point (e.g., &quot;N.&quot; instead of &quot;N&quot;).</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FormatTimeInMillisAsSeconds</span><span class="p">(</span><span class="n">TimeInMillis</span><span class="w"> </span><span class="n">ms</span><span class="p">);</span>

<span class="c1">// Converts the given time in milliseconds to a date string in the ISO 8601</span>
<span class="c1">// format, without the timezone information.  N.B.: due to the use the</span>
<span class="c1">// non-reentrant localtime() function, this function is not thread safe.  Do</span>
<span class="c1">// not use it in any code that can be called from multiple threads.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FormatEpochTimeInMillisAsIso8601</span><span class="p">(</span><span class="n">TimeInMillis</span><span class="w"> </span><span class="n">ms</span><span class="p">);</span>

<span class="c1">// Parses a string for an Int32 flag, in the form of &quot;--flag=value&quot;.</span>
<span class="c1">//</span>
<span class="c1">// On success, stores the value of the flag in *value, and returns</span>
<span class="c1">// true.  On failure, returns false without changing *value.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ParseFlag</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="c1">// Returns a random seed in range [1, kMaxRandomSeed] based on the</span>
<span class="c1">// given --gtest_random_seed flag value.</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetRandomSeedFromFlag</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">random_seed_flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">raw_seed</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">random_seed_flag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetTimeInMillis</span><span class="p">())</span>
<span class="w">                              </span><span class="o">:</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">random_seed_flag</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Normalizes the actual seed to range [1, kMaxRandomSeed] such that</span>
<span class="w">  </span><span class="c1">// it&#39;s easy to type.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">normalized_seed</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">((</span><span class="n">raw_seed</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1U</span><span class="p">)</span><span class="w"> </span><span class="o">%</span>
<span class="w">                       </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kMaxRandomSeed</span><span class="p">))</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">normalized_seed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns the first valid random seed after &#39;seed&#39;.  The behavior is</span>
<span class="c1">// undefined if &#39;seed&#39; is invalid.  The seed after kMaxRandomSeed is</span>
<span class="c1">// considered to be 1.</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetNextRandomSeed</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">seed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">kMaxRandomSeed</span><span class="p">)</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid random seed &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; - must be in [1, &quot;</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">kMaxRandomSeed</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;].&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">next_seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">next_seed</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">kMaxRandomSeed</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">next_seed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This class saves the values of all Google Test flags in its c&#39;tor, and</span>
<span class="c1">// restores them in its d&#39;tor.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GTestFlagSaver</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// The c&#39;tor.</span>
<span class="w">  </span><span class="n">GTestFlagSaver</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">also_run_disabled_tests_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">also_run_disabled_tests</span><span class="p">);</span>
<span class="w">    </span><span class="n">break_on_failure_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">break_on_failure</span><span class="p">);</span>
<span class="w">    </span><span class="n">catch_exceptions_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">catch_exceptions</span><span class="p">);</span>
<span class="w">    </span><span class="n">color_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
<span class="w">    </span><span class="n">death_test_style_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">death_test_style</span><span class="p">);</span>
<span class="w">    </span><span class="n">death_test_use_fork_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">death_test_use_fork</span><span class="p">);</span>
<span class="w">    </span><span class="n">fail_fast_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">fail_fast</span><span class="p">);</span>
<span class="w">    </span><span class="n">filter_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
<span class="w">    </span><span class="n">internal_run_death_test_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">internal_run_death_test</span><span class="p">);</span>
<span class="w">    </span><span class="n">list_tests_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">list_tests</span><span class="p">);</span>
<span class="w">    </span><span class="n">output_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
<span class="w">    </span><span class="n">brief_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">brief</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_time_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">print_time</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_utf8_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">print_utf8</span><span class="p">);</span>
<span class="w">    </span><span class="n">random_seed_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">random_seed</span><span class="p">);</span>
<span class="w">    </span><span class="n">repeat_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">repeat</span><span class="p">);</span>
<span class="w">    </span><span class="n">recreate_environments_when_repeating_</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">recreate_environments_when_repeating</span><span class="p">);</span>
<span class="w">    </span><span class="n">shuffle_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">shuffle</span><span class="p">);</span>
<span class="w">    </span><span class="n">stack_trace_depth_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">stack_trace_depth</span><span class="p">);</span>
<span class="w">    </span><span class="n">stream_result_to_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">stream_result_to</span><span class="p">);</span>
<span class="w">    </span><span class="n">throw_on_failure_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GTEST_FLAG_GET</span><span class="p">(</span><span class="n">throw_on_failure</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// The d&#39;tor is not virtual.  DO NOT INHERIT FROM THIS CLASS.</span>
<span class="w">  </span><span class="o">~</span><span class="n">GTestFlagSaver</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">also_run_disabled_tests</span><span class="p">,</span><span class="w"> </span><span class="n">also_run_disabled_tests_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">break_on_failure</span><span class="p">,</span><span class="w"> </span><span class="n">break_on_failure_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">catch_exceptions</span><span class="p">,</span><span class="w"> </span><span class="n">catch_exceptions_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">color_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">death_test_style</span><span class="p">,</span><span class="w"> </span><span class="n">death_test_style_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">death_test_use_fork</span><span class="p">,</span><span class="w"> </span><span class="n">death_test_use_fork_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="n">filter_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">fail_fast</span><span class="p">,</span><span class="w"> </span><span class="n">fail_fast_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">internal_run_death_test</span><span class="p">,</span><span class="w"> </span><span class="n">internal_run_death_test_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">list_tests</span><span class="p">,</span><span class="w"> </span><span class="n">list_tests_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">output_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">brief</span><span class="p">,</span><span class="w"> </span><span class="n">brief_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">print_time</span><span class="p">,</span><span class="w"> </span><span class="n">print_time_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">print_utf8</span><span class="p">,</span><span class="w"> </span><span class="n">print_utf8_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">random_seed</span><span class="p">,</span><span class="w"> </span><span class="n">random_seed_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">repeat</span><span class="p">,</span><span class="w"> </span><span class="n">repeat_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">recreate_environments_when_repeating</span><span class="p">,</span>
<span class="w">                   </span><span class="n">recreate_environments_when_repeating_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span><span class="w"> </span><span class="n">shuffle_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">stack_trace_depth</span><span class="p">,</span><span class="w"> </span><span class="n">stack_trace_depth_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">stream_result_to</span><span class="p">,</span><span class="w"> </span><span class="n">stream_result_to_</span><span class="p">);</span>
<span class="w">    </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">throw_on_failure</span><span class="p">,</span><span class="w"> </span><span class="n">throw_on_failure_</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Fields for saving the original values of flags.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">also_run_disabled_tests_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">break_on_failure_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">catch_exceptions_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">color_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">death_test_style_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">death_test_use_fork_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">fail_fast_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">filter_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">internal_run_death_test_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">list_tests_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">output_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">brief_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">print_time_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">print_utf8_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">random_seed_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">repeat_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">recreate_environments_when_repeating_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">shuffle_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">stack_trace_depth_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">stream_result_to_</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">throw_on_failure_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Converts a Unicode code point to a narrow string in UTF-8 encoding.</span>
<span class="c1">// code_point parameter is of type UInt32 because wchar_t may not be</span>
<span class="c1">// wide enough to contain a code point.</span>
<span class="c1">// If the code_point is not a valid Unicode code point</span>
<span class="c1">// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted</span>
<span class="c1">// to &quot;(Invalid Unicode 0xXXXXXXXX)&quot;.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">CodePointToUtf8</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">code_point</span><span class="p">);</span>

<span class="c1">// Converts a wide string to a narrow string in UTF-8 encoding.</span>
<span class="c1">// The wide string is assumed to have the following encoding:</span>
<span class="c1">//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)</span>
<span class="c1">//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)</span>
<span class="c1">// Parameter str points to a null-terminated wide string.</span>
<span class="c1">// Parameter num_chars may additionally limit the number</span>
<span class="c1">// of wchar_t characters processed. -1 is used when the entire string</span>
<span class="c1">// should be processed.</span>
<span class="c1">// If the string contains code points that are not valid Unicode code points</span>
<span class="c1">// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output</span>
<span class="c1">// as &#39;(Invalid Unicode 0xXXXXXXXX)&#39;. If the string is in UTF16 encoding</span>
<span class="c1">// and contains invalid UTF-16 surrogate pairs, values in those pairs</span>
<span class="c1">// will be encoded as individual Unicode characters from Basic Normal Plane.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">WideStringToUtf8</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">wchar_t</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_chars</span><span class="p">);</span>

<span class="c1">// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file</span>
<span class="c1">// if the variable is present. If a file already exists at this location, this</span>
<span class="c1">// function will write over it. If the variable is present, but the file cannot</span>
<span class="c1">// be created, prints an error and exits.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">WriteToShardStatusFileIfNeeded</span><span class="p">();</span>

<span class="c1">// Checks whether sharding is enabled by examining the relevant</span>
<span class="c1">// environment variable values. If the variables are present,</span>
<span class="c1">// but inconsistent (e.g., shard_index &gt;= total_shards), prints</span>
<span class="c1">// an error and exits. If in_subprocess_for_death_test, sharding is</span>
<span class="c1">// disabled because it must only be applied to the original test</span>
<span class="c1">// process. Otherwise, we could filter out death tests we intended to execute.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ShouldShard</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">total_shards_str</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">shard_index_str</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_subprocess_for_death_test</span><span class="p">);</span>

<span class="c1">// Parses the environment variable var as a 32-bit integer. If it is unset,</span>
<span class="c1">// returns default_val. If it is not a 32-bit integer, prints an error and</span>
<span class="c1">// and aborts.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">Int32FromEnvOrDie</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">env_var</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">default_val</span><span class="p">);</span>

<span class="c1">// Given the total number of shards, the shard index, and the test id,</span>
<span class="c1">// returns true if and only if the test should be run on this shard. The test id</span>
<span class="c1">// is some arbitrary but unique non-negative integer assigned to each test</span>
<span class="c1">// method. Assumes that 0 &lt;= shard_index &lt; total_shards.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ShouldRunTestOnShard</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">total_shards</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shard_index</span><span class="p">,</span>
<span class="w">                                     </span><span class="kt">int</span><span class="w"> </span><span class="n">test_id</span><span class="p">);</span>

<span class="c1">// STL container utilities.</span>

<span class="c1">// Returns the number of elements in the given container that satisfy</span>
<span class="c1">// the given predicate.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CountIf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">Predicate</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Implemented as an explicit loop since std::count_if() in libCstd on</span>
<span class="w">  </span><span class="c1">// Solaris has a non-standard signature.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">))</span><span class="w"> </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Applies a function/functor to each element in the container.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Functor</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">ForEach</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">functor</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Returns the i-th element of the vector, or default_value if i is not</span>
<span class="c1">// in range [0, v.size()).</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">E</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="n">GetElementOr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="n">default_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">default_value</span>
<span class="w">                                                    </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)];</span>
<span class="p">}</span>

<span class="c1">// Performs an in-place shuffle of a range of the vector&#39;s elements.</span>
<span class="c1">// &#39;begin&#39; and &#39;end&#39; are element indices as an STL-style range;</span>
<span class="c1">// i.e. [begin, end) are shuffled, where &#39;end&#39; == size() means to</span>
<span class="c1">// shuffle to the end of the vector.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">E</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">ShuffleRange</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">Random</span><span class="o">*</span><span class="w"> </span><span class="n">random</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">,</span>
<span class="w">                  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid shuffle range start &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: must be in range [0, &quot;</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;].&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="n">begin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid shuffle range finish &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: must be in range [&quot;</span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;].&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Fisher-Yates shuffle, from</span>
<span class="w">  </span><span class="c1">// https://en.wikipedia.org/wiki/Fisher-Yates_shuffle</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">range_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">range_width</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">range_width</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">last_in_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">range_width</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selected</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">begin</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">random</span><span class="o">-&gt;</span><span class="n">Generate</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">range_width</span><span class="p">)));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">((</span><span class="o">*</span><span class="n">v</span><span class="p">)[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">selected</span><span class="p">)],</span>
<span class="w">              </span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">last_in_range</span><span class="p">)]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Performs an in-place shuffle of the vector&#39;s elements.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">E</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Shuffle</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">Random</span><span class="o">*</span><span class="w"> </span><span class="n">random</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ShuffleRange</span><span class="p">(</span><span class="n">random</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()),</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// A function for deleting an object.  Handy for being used as a</span>
<span class="c1">// functor.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Delete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A predicate that checks the key of a TestProperty against a known key.</span>
<span class="c1">//</span>
<span class="c1">// TestPropertyKeyIs is copyable.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TestPropertyKeyIs</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Constructor.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// TestPropertyKeyIs has NO default constructor.</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">TestPropertyKeyIs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">key_</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Returns true if and only if the test name of test property matches on key_.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">TestProperty</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_property</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">test_property</span><span class="p">.</span><span class="n">key</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">key_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Class UnitTestOptions.</span>
<span class="c1">//</span>
<span class="c1">// This class contains functions for processing options the user</span>
<span class="c1">// specifies when running the tests.  It has only static members.</span>
<span class="c1">//</span>
<span class="c1">// In most cases, the user can specify an option using either an</span>
<span class="c1">// environment variable or a command line flag.  E.g. you can set the</span>
<span class="c1">// test filter using either GTEST_FILTER or --gtest_filter.  If both</span>
<span class="c1">// the variable and the flag are present, the latter overrides the</span>
<span class="c1">// former.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GTEST_API_</span><span class="w"> </span><span class="n">UnitTestOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Functions for processing the gtest_output flag.</span>

<span class="w">  </span><span class="c1">// Returns the output format, or &quot;&quot; for normal printed output.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">GetOutputFormat</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns the absolute path of the requested output file, or the</span>
<span class="w">  </span><span class="c1">// default (test_detail.xml in the original working directory) if</span>
<span class="w">  </span><span class="c1">// none was explicitly specified.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetAbsolutePathToOutputFile</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Functions for processing the gtest_filter flag.</span>

<span class="w">  </span><span class="c1">// Returns true if and only if the user-specified filter matches the test</span>
<span class="w">  </span><span class="c1">// suite name and the test name.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">FilterMatchesTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_suite_name</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_name</span><span class="p">);</span>

<span class="cp">#ifdef GTEST_OS_WINDOWS</span>
<span class="w">  </span><span class="c1">// Function for supporting the gtest_catch_exception flag.</span>

<span class="w">  </span><span class="c1">// Returns EXCEPTION_EXECUTE_HANDLER if given SEH exception was handled, or</span>
<span class="w">  </span><span class="c1">// EXCEPTION_CONTINUE_SEARCH otherwise.</span>
<span class="w">  </span><span class="c1">// This function is useful as an __except condition.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GTestProcessSEH</span><span class="p">(</span><span class="n">DWORD</span><span class="w"> </span><span class="n">seh_code</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">location</span><span class="p">);</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_OS_WINDOWS</span>

<span class="w">  </span><span class="c1">// Returns true if &quot;name&quot; matches the &#39;:&#39; separated list of glob-style</span>
<span class="w">  </span><span class="c1">// filters in &quot;filter&quot;.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">MatchesFilter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filter</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#if GTEST_HAS_FILE_SYSTEM</span>
<span class="c1">// Returns the current application&#39;s name, removing directory path if that</span>
<span class="c1">// is present.  Used by UnitTestOptions::GetOutputFile.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">FilePath</span><span class="w"> </span><span class="n">GetCurrentExecutableName</span><span class="p">();</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_FILE_SYSTEM</span>

<span class="c1">// The role interface for getting the OS stack trace as a string.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OsStackTraceGetterInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">OsStackTraceGetterInterface</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">OsStackTraceGetterInterface</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Returns the current OS stack trace as an std::string.  Parameters:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//   max_depth  - the maximum number of stack frames to be included</span>
<span class="w">  </span><span class="c1">//                in the trace.</span>
<span class="w">  </span><span class="c1">//   skip_count - the number of top frames to be skipped; doesn&#39;t count</span>
<span class="w">  </span><span class="c1">//                against max_depth.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">CurrentStackTrace</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_depth</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">skip_count</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// UponLeavingGTest() should be called immediately before Google Test calls</span>
<span class="w">  </span><span class="c1">// user code. It saves some information about the current stack that</span>
<span class="w">  </span><span class="c1">// CurrentStackTrace() will use to find and hide Google Test stack frames.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">UponLeavingGTest</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// This string is inserted in place of stack frames that are part of</span>
<span class="w">  </span><span class="c1">// Google Test&#39;s implementation.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">kElidedFramesMarker</span><span class="p">;</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">OsStackTraceGetterInterface</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OsStackTraceGetterInterface</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">OsStackTraceGetterInterface</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OsStackTraceGetterInterface</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A working implementation of the OsStackTraceGetterInterface interface.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OsStackTraceGetter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OsStackTraceGetterInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">OsStackTraceGetter</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">CurrentStackTrace</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_depth</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">skip_count</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">UponLeavingGTest</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="cp">#ifdef GTEST_HAS_ABSL</span>
<span class="w">  </span><span class="n">Mutex</span><span class="w"> </span><span class="n">mutex_</span><span class="p">;</span><span class="w">  </span><span class="c1">// Protects all internal state.</span>

<span class="w">  </span><span class="c1">// We save the stack frame below the frame that calls user code.</span>
<span class="w">  </span><span class="c1">// We do this because the address of the frame immediately below</span>
<span class="w">  </span><span class="c1">// the user code changes between the call to UponLeavingGTest()</span>
<span class="w">  </span><span class="c1">// and any calls to the stack trace code from within the user code.</span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">caller_frame_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_ABSL</span>

<span class="w">  </span><span class="n">OsStackTraceGetter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OsStackTraceGetter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">OsStackTraceGetter</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OsStackTraceGetter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Information about a Google Test trace point.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TraceInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">message</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This is the default global test part result reporter used in UnitTestImpl.</span>
<span class="c1">// This class should only be used by UnitTestImpl.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultGlobalTestPartResultReporter</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TestPartResultReporterInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="p">(</span><span class="n">UnitTestImpl</span><span class="o">*</span><span class="w"> </span><span class="n">unit_test</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Implements the TestPartResultReporterInterface. Reports the test part</span>
<span class="w">  </span><span class="c1">// result in the current test.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ReportTestPartResult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestPartResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">UnitTestImpl</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">unit_test_</span><span class="p">;</span>

<span class="w">  </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This is the default per thread test part result reporter used in</span>
<span class="c1">// UnitTestImpl. This class should only be used by UnitTestImpl.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultPerThreadTestPartResultReporter</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TestPartResultReporterInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">DefaultPerThreadTestPartResultReporter</span><span class="p">(</span><span class="n">UnitTestImpl</span><span class="o">*</span><span class="w"> </span><span class="n">unit_test</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Implements the TestPartResultReporterInterface. The implementation just</span>
<span class="w">  </span><span class="c1">// delegates to the current global test part result reporter of *unit_test_.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ReportTestPartResult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestPartResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">UnitTestImpl</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">unit_test_</span><span class="p">;</span>

<span class="w">  </span><span class="n">DefaultPerThreadTestPartResultReporter</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">DefaultPerThreadTestPartResultReporter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">DefaultPerThreadTestPartResultReporter</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">DefaultPerThreadTestPartResultReporter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The private implementation of the UnitTest class.  We don&#39;t protect</span>
<span class="c1">// the methods under a mutex, as this class is not accessible by a</span>
<span class="c1">// user and the UnitTest class that delegates work to this class does</span>
<span class="c1">// proper locking.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GTEST_API_</span><span class="w"> </span><span class="n">UnitTestImpl</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">UnitTestImpl</span><span class="p">(</span><span class="n">UnitTest</span><span class="o">*</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">UnitTestImpl</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// There are two different ways to register your own TestPartResultReporter.</span>
<span class="w">  </span><span class="c1">// You can register your own reporter to listen either only for test results</span>
<span class="w">  </span><span class="c1">// from the current thread or for results from all threads.</span>
<span class="w">  </span><span class="c1">// By default, each per-thread test result reporter just passes a new</span>
<span class="w">  </span><span class="c1">// TestPartResult to the global test result reporter, which registers the</span>
<span class="w">  </span><span class="c1">// test part result for the currently running test.</span>

<span class="w">  </span><span class="c1">// Returns the global test part result reporter.</span>
<span class="w">  </span><span class="n">TestPartResultReporterInterface</span><span class="o">*</span><span class="w"> </span><span class="nf">GetGlobalTestPartResultReporter</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Sets the global test part result reporter.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetGlobalTestPartResultReporter</span><span class="p">(</span>
<span class="w">      </span><span class="n">TestPartResultReporterInterface</span><span class="o">*</span><span class="w"> </span><span class="n">reporter</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Returns the test part result reporter for the current thread.</span>
<span class="w">  </span><span class="n">TestPartResultReporterInterface</span><span class="o">*</span><span class="w"> </span><span class="nf">GetTestPartResultReporterForCurrentThread</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Sets the test part result reporter for the current thread.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetTestPartResultReporterForCurrentThread</span><span class="p">(</span>
<span class="w">      </span><span class="n">TestPartResultReporterInterface</span><span class="o">*</span><span class="w"> </span><span class="n">reporter</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Gets the number of successful test suites.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">successful_test_suite_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of failed test suites.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">failed_test_suite_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of all test suites.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">total_test_suite_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of all test suites that contain at least one test</span>
<span class="w">  </span><span class="c1">// that should run.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">test_suite_to_run_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of successful tests.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">successful_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of skipped tests.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">skipped_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of failed tests.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">failed_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of disabled tests that will be reported in the XML report.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">reportable_disabled_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of disabled tests.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">disabled_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of tests to be printed in the XML report.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">reportable_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of all tests.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">total_test_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the number of tests that should run.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">test_to_run_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Gets the time of the test program start, in ms from the start of the</span>
<span class="w">  </span><span class="c1">// UNIX epoch.</span>
<span class="w">  </span><span class="n">TimeInMillis</span><span class="w"> </span><span class="nf">start_timestamp</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">start_timestamp_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Gets the elapsed time, in milliseconds.</span>
<span class="w">  </span><span class="n">TimeInMillis</span><span class="w"> </span><span class="nf">elapsed_time</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">elapsed_time_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns true if and only if the unit test passed (i.e. all test suites</span>
<span class="w">  </span><span class="c1">// passed).</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Passed</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">Failed</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns true if and only if the unit test failed (i.e. some test suite</span>
<span class="w">  </span><span class="c1">// failed or something outside of all tests failed).</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Failed</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">failed_test_suite_count</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ad_hoc_test_result</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Failed</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Gets the i-th test suite among all the test suites. i can range from 0 to</span>
<span class="w">  </span><span class="c1">// total_test_suite_count() - 1. If i is not in that range, returns NULL.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="nf">GetTestSuite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElementOr</span><span class="p">(</span><span class="n">test_suite_indices_</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">test_suites_</span><span class="p">[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//  Legacy API is deprecated but still available</span>
<span class="cp">#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TestCase</span><span class="o">*</span><span class="w"> </span><span class="nf">GetTestCase</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">GetTestSuite</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#endif  </span><span class="c1">//  GTEST_REMOVE_LEGACY_TEST_CASEAPI_</span>

<span class="w">  </span><span class="c1">// Gets the i-th test suite among all the test suites. i can range from 0 to</span>
<span class="w">  </span><span class="c1">// total_test_suite_count() - 1. If i is not in that range, returns NULL.</span>
<span class="w">  </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="nf">GetMutableSuiteCase</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElementOr</span><span class="p">(</span><span class="n">test_suite_indices_</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">test_suites_</span><span class="p">[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">)];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Provides access to the event listener list.</span>
<span class="w">  </span><span class="n">TestEventListeners</span><span class="o">*</span><span class="w"> </span><span class="nf">listeners</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">listeners_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns the TestResult for the test that&#39;s currently running, or</span>
<span class="w">  </span><span class="c1">// the TestResult for the ad hoc test if no test is running.</span>
<span class="w">  </span><span class="n">TestResult</span><span class="o">*</span><span class="w"> </span><span class="nf">current_test_result</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns the TestResult for the ad hoc test.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TestResult</span><span class="o">*</span><span class="w"> </span><span class="nf">ad_hoc_test_result</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ad_hoc_test_result_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Sets the OS stack trace getter.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// Does nothing if the input and the current OS stack trace getter</span>
<span class="w">  </span><span class="c1">// are the same; otherwise, deletes the old getter and makes the</span>
<span class="w">  </span><span class="c1">// input the current getter.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_os_stack_trace_getter</span><span class="p">(</span><span class="n">OsStackTraceGetterInterface</span><span class="o">*</span><span class="w"> </span><span class="n">getter</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Returns the current OS stack trace getter if it is not NULL;</span>
<span class="w">  </span><span class="c1">// otherwise, creates an OsStackTraceGetter, makes it the current</span>
<span class="w">  </span><span class="c1">// getter, and returns it.</span>
<span class="w">  </span><span class="n">OsStackTraceGetterInterface</span><span class="o">*</span><span class="w"> </span><span class="nf">os_stack_trace_getter</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns the current OS stack trace as an std::string.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// The maximum number of stack frames to be included is specified by</span>
<span class="w">  </span><span class="c1">// the gtest_stack_trace_depth flag.  The skip_count parameter</span>
<span class="w">  </span><span class="c1">// specifies the number of top frames to be skipped, which doesn&#39;t</span>
<span class="w">  </span><span class="c1">// count against the number of frames to be included.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// For example, if Foo() calls Bar(), which in turn calls</span>
<span class="w">  </span><span class="c1">// CurrentOsStackTraceExceptTop(1), Foo() will be included in the</span>
<span class="w">  </span><span class="c1">// trace but Bar() and CurrentOsStackTraceExceptTop() won&#39;t.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">CurrentOsStackTraceExceptTop</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">skip_count</span><span class="p">)</span>
<span class="w">      </span><span class="n">GTEST_NO_INLINE_</span><span class="w"> </span><span class="n">GTEST_NO_TAIL_CALL_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Finds and returns a TestSuite with the given name.  If one doesn&#39;t</span>
<span class="w">  </span><span class="c1">// exist, creates one and returns it.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// Arguments:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//   test_suite_name: name of the test suite</span>
<span class="w">  </span><span class="c1">//   type_param:      the name of the test&#39;s type parameter, or NULL if</span>
<span class="w">  </span><span class="c1">//                    this is not a typed or a type-parameterized test.</span>
<span class="w">  </span><span class="c1">//   set_up_tc:       pointer to the function that sets up the test suite</span>
<span class="w">  </span><span class="c1">//   tear_down_tc:    pointer to the function that tears down the test suite</span>
<span class="w">  </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="nf">GetTestSuite</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_suite_name</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type_param</span><span class="p">,</span>
<span class="w">                          </span><span class="n">internal</span><span class="o">::</span><span class="n">SetUpTestSuiteFunc</span><span class="w"> </span><span class="n">set_up_tc</span><span class="p">,</span>
<span class="w">                          </span><span class="n">internal</span><span class="o">::</span><span class="n">TearDownTestSuiteFunc</span><span class="w"> </span><span class="n">tear_down_tc</span><span class="p">);</span>

<span class="c1">//  Legacy API is deprecated but still available</span>
<span class="cp">#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_</span>
<span class="w">  </span><span class="n">TestCase</span><span class="o">*</span><span class="w"> </span><span class="nf">GetTestCase</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_case_name</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type_param</span><span class="p">,</span>
<span class="w">                        </span><span class="n">internal</span><span class="o">::</span><span class="n">SetUpTestSuiteFunc</span><span class="w"> </span><span class="n">set_up_tc</span><span class="p">,</span>
<span class="w">                        </span><span class="n">internal</span><span class="o">::</span><span class="n">TearDownTestSuiteFunc</span><span class="w"> </span><span class="n">tear_down_tc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">GetTestSuite</span><span class="p">(</span><span class="n">test_case_name</span><span class="p">,</span><span class="w"> </span><span class="n">type_param</span><span class="p">,</span><span class="w"> </span><span class="n">set_up_tc</span><span class="p">,</span><span class="w"> </span><span class="n">tear_down_tc</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="cp">#endif  </span><span class="c1">//  GTEST_REMOVE_LEGACY_TEST_CASEAPI_</span>

<span class="w">  </span><span class="c1">// Adds a TestInfo to the unit test.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// Arguments:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//   set_up_tc:    pointer to the function that sets up the test suite</span>
<span class="w">  </span><span class="c1">//   tear_down_tc: pointer to the function that tears down the test suite</span>
<span class="w">  </span><span class="c1">//   test_info:    the TestInfo object</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">AddTestInfo</span><span class="p">(</span><span class="n">internal</span><span class="o">::</span><span class="n">SetUpTestSuiteFunc</span><span class="w"> </span><span class="n">set_up_tc</span><span class="p">,</span>
<span class="w">                   </span><span class="n">internal</span><span class="o">::</span><span class="n">TearDownTestSuiteFunc</span><span class="w"> </span><span class="n">tear_down_tc</span><span class="p">,</span>
<span class="w">                   </span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="n">test_info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#if GTEST_HAS_FILE_SYSTEM</span>
<span class="w">    </span><span class="c1">// In order to support thread-safe death tests, we need to</span>
<span class="w">    </span><span class="c1">// remember the original working directory when the test program</span>
<span class="w">    </span><span class="c1">// was first invoked.  We cannot do this in RUN_ALL_TESTS(), as</span>
<span class="w">    </span><span class="c1">// the user may have changed the current directory before calling</span>
<span class="w">    </span><span class="c1">// RUN_ALL_TESTS().  Therefore we capture the current directory in</span>
<span class="w">    </span><span class="c1">// AddTestInfo(), which is called to register a TEST or TEST_F</span>
<span class="w">    </span><span class="c1">// before main() is reached.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">original_working_dir_</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">original_working_dir_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FilePath</span><span class="o">::</span><span class="n">GetCurrentDir</span><span class="p">();</span>
<span class="w">      </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="o">!</span><span class="n">original_working_dir_</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">())</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to get the current working directory.&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_FILE_SYSTEM</span>

<span class="w">    </span><span class="n">GetTestSuite</span><span class="p">(</span><span class="n">test_info</span><span class="o">-&gt;</span><span class="n">test_suite_name_</span><span class="p">,</span><span class="w"> </span><span class="n">test_info</span><span class="o">-&gt;</span><span class="n">type_param</span><span class="p">(),</span>
<span class="w">                 </span><span class="n">set_up_tc</span><span class="p">,</span><span class="w"> </span><span class="n">tear_down_tc</span><span class="p">)</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="n">AddTestInfo</span><span class="p">(</span><span class="n">test_info</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns ParameterizedTestSuiteRegistry object used to keep track of</span>
<span class="w">  </span><span class="c1">// value-parameterized tests and instantiate and register them.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">ParameterizedTestSuiteRegistry</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">parameterized_test_registry</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parameterized_test_registry_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">ignored_parameterized_test_suites</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ignored_parameterized_test_suites_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns TypeParameterizedTestSuiteRegistry object used to keep track of</span>
<span class="w">  </span><span class="c1">// type-parameterized tests and instantiations of them.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">TypeParameterizedTestSuiteRegistry</span><span class="o">&amp;</span>
<span class="w">  </span><span class="n">type_parameterized_test_registry</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">type_parameterized_test_registry_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Registers all parameterized tests defined using TEST_P and</span>
<span class="w">  </span><span class="c1">// INSTANTIATE_TEST_SUITE_P, creating regular tests for each test/parameter</span>
<span class="w">  </span><span class="c1">// combination. This method can be called more then once; it has guards</span>
<span class="w">  </span><span class="c1">// protecting from registering the tests more then once.  If</span>
<span class="w">  </span><span class="c1">// value-parameterized tests are disabled, RegisterParameterizedTests is</span>
<span class="w">  </span><span class="c1">// present but does nothing.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">RegisterParameterizedTests</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Runs all tests in this UnitTest object, prints the result, and</span>
<span class="w">  </span><span class="c1">// returns true if all tests are successful.  If any exception is</span>
<span class="w">  </span><span class="c1">// thrown during a test, this test is considered to be failed, but</span>
<span class="w">  </span><span class="c1">// the rest of the tests will still be run.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">RunAllTests</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Clears the results of all tests, except the ad hoc tests.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ClearNonAdHocTestResult</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ForEach</span><span class="p">(</span><span class="n">test_suites_</span><span class="p">,</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">::</span><span class="n">ClearTestSuiteResult</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Clears the results of ad-hoc test assertions.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ClearAdHocTestResult</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ad_hoc_test_result_</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Adds a TestProperty to the current TestResult object when invoked in a</span>
<span class="w">  </span><span class="c1">// context of a test or a test suite, or to the global property set. If the</span>
<span class="w">  </span><span class="c1">// result already contains a property with the same key, the value will be</span>
<span class="w">  </span><span class="c1">// updated.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">RecordProperty</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestProperty</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_property</span><span class="p">);</span>

<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">ReactionToSharding</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">HONOR_SHARDING_PROTOCOL</span><span class="p">,</span><span class="w"> </span><span class="n">IGNORE_SHARDING_PROTOCOL</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Matches the full name of each test against the user-specified</span>
<span class="w">  </span><span class="c1">// filter to decide whether the test should run, then records the</span>
<span class="w">  </span><span class="c1">// result in each TestSuite and TestInfo object.</span>
<span class="w">  </span><span class="c1">// If shard_tests == HONOR_SHARDING_PROTOCOL, further filters tests</span>
<span class="w">  </span><span class="c1">// based on sharding variables in the environment.</span>
<span class="w">  </span><span class="c1">// Returns the number of tests that should run.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">FilterTests</span><span class="p">(</span><span class="n">ReactionToSharding</span><span class="w"> </span><span class="n">shard_tests</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Prints the names of the tests matching the user-specified filter flag.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ListTestsMatchingFilter</span><span class="p">();</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="nf">current_test_suite</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">current_test_suite_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="nf">current_test_info</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">current_test_info_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="nf">current_test_info</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">current_test_info_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns the vector of environments that need to be set-up/torn-down</span>
<span class="w">  </span><span class="c1">// before/after the tests are run.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Environment</span><span class="o">*&gt;&amp;</span><span class="w"> </span><span class="n">environments</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">environments_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Getters for the per-thread Google Test trace stack.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TraceInfo</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">gtest_trace_stack</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">gtest_trace_stack_</span><span class="p">.</span><span class="n">pointer</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TraceInfo</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">gtest_trace_stack</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">gtest_trace_stack_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="cp">#ifdef GTEST_HAS_DEATH_TEST</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">InitDeathTestSubprocessControlInfo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">internal_run_death_test_flag_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ParseInternalRunDeathTestFlag</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Returns a pointer to the parsed --gtest_internal_run_death_test</span>
<span class="w">  </span><span class="c1">// flag, or NULL if that flag was not specified.</span>
<span class="w">  </span><span class="c1">// This information is useful only in a death test child process.</span>
<span class="w">  </span><span class="c1">// Must not be called before a call to InitGoogleTest.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">InternalRunDeathTestFlag</span><span class="o">*</span><span class="w"> </span><span class="n">internal_run_death_test_flag</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">internal_run_death_test_flag_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns a pointer to the current death test factory.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">DeathTestFactory</span><span class="o">*</span><span class="w"> </span><span class="n">death_test_factory</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">death_test_factory_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SuppressTestEventsIfInSubprocess</span><span class="p">();</span>

<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ReplaceDeathTestFactory</span><span class="p">;</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_DEATH_TEST</span>

<span class="w">  </span><span class="c1">// Initializes the event listener performing XML output as specified by</span>
<span class="w">  </span><span class="c1">// UnitTestOptions. Must not be called before InitGoogleTest.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ConfigureXmlOutput</span><span class="p">();</span>

<span class="cp">#if GTEST_CAN_STREAM_RESULTS_</span>
<span class="w">  </span><span class="c1">// Initializes the event listener for streaming test results to a socket.</span>
<span class="w">  </span><span class="c1">// Must not be called before InitGoogleTest.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ConfigureStreamingOutput</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="c1">// Performs initialization dependent upon flag values obtained in</span>
<span class="w">  </span><span class="c1">// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to</span>
<span class="w">  </span><span class="c1">// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest</span>
<span class="w">  </span><span class="c1">// this function is also called from RunAllTests.  Since this function can be</span>
<span class="w">  </span><span class="c1">// called more than once, it has to be idempotent.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">PostFlagParsingInit</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Gets the random seed used at the start of the current test iteration.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">random_seed</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">random_seed_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Gets the random number generator.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">Random</span><span class="o">*</span><span class="w"> </span><span class="nf">random</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">random_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Shuffles all test suites, and the tests within each test suite,</span>
<span class="w">  </span><span class="c1">// making sure that death tests are still run first.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ShuffleTests</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Restores the test suites and tests to their order before the first shuffle.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">UnshuffleTests</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns the value of GTEST_FLAG(catch_exceptions) at the moment</span>
<span class="w">  </span><span class="c1">// UnitTest::Run() starts.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">catch_exceptions</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">catch_exceptions_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">CompareTestSuitesByPointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">name_</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="o">-&gt;</span><span class="n">name_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">UnitTest</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Used by UnitTest::Run() to capture the state of</span>
<span class="w">  </span><span class="c1">// GTEST_FLAG(catch_exceptions) at the moment it starts.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_catch_exceptions</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">catch_exceptions_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Sets the TestSuite object for the test that&#39;s currently running.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_current_test_suite</span><span class="p">(</span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="n">a_current_test_suite</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current_test_suite_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_current_test_suite</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Sets the TestInfo object for the test that&#39;s currently running.  If</span>
<span class="w">  </span><span class="c1">// current_test_info is NULL, the assertion results will be stored in</span>
<span class="w">  </span><span class="c1">// ad_hoc_test_result_.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_current_test_info</span><span class="p">(</span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="n">a_current_test_info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current_test_info_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_current_test_info</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// The UnitTest object that owns this implementation object.</span>
<span class="w">  </span><span class="n">UnitTest</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">parent_</span><span class="p">;</span>

<span class="cp">#if GTEST_HAS_FILE_SYSTEM</span>
<span class="w">  </span><span class="c1">// The working directory when the first TEST() or TEST_F() was</span>
<span class="w">  </span><span class="c1">// executed.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">FilePath</span><span class="w"> </span><span class="n">original_working_dir_</span><span class="p">;</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_FILE_SYSTEM</span>

<span class="w">  </span><span class="c1">// The default test part result reporters.</span>
<span class="w">  </span><span class="n">DefaultGlobalTestPartResultReporter</span><span class="w"> </span><span class="n">default_global_test_part_result_reporter_</span><span class="p">;</span>
<span class="w">  </span><span class="n">DefaultPerThreadTestPartResultReporter</span>
<span class="w">      </span><span class="n">default_per_thread_test_part_result_reporter_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Points to (but doesn&#39;t own) the global test part result reporter.</span>
<span class="w">  </span><span class="n">TestPartResultReporterInterface</span><span class="o">*</span><span class="w"> </span><span class="n">global_test_part_result_reporter_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Protects read and write access to global_test_part_result_reporter_.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">Mutex</span><span class="w"> </span><span class="n">global_test_part_result_reporter_mutex_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Points to (but doesn&#39;t own) the per-thread test part result reporter.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">TestPartResultReporterInterface</span><span class="o">*&gt;</span>
<span class="w">      </span><span class="n">per_thread_test_part_result_reporter_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The vector of environments that need to be set-up/torn-down</span>
<span class="w">  </span><span class="c1">// before/after the tests are run.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Environment</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">environments_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The vector of TestSuites in their original order.  It owns the</span>
<span class="w">  </span><span class="c1">// elements in the vector.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestSuite</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">test_suites_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The set of TestSuites by name.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">test_suites_by_name_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Provides a level of indirection for the test suite list to allow</span>
<span class="w">  </span><span class="c1">// easy shuffling and restoring the test suite order.  The i-th</span>
<span class="w">  </span><span class="c1">// element of this vector is the index of the i-th test suite in the</span>
<span class="w">  </span><span class="c1">// shuffled order.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">test_suite_indices_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ParameterizedTestRegistry object used to register value-parameterized</span>
<span class="w">  </span><span class="c1">// tests.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">ParameterizedTestSuiteRegistry</span><span class="w"> </span><span class="n">parameterized_test_registry_</span><span class="p">;</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">TypeParameterizedTestSuiteRegistry</span>
<span class="w">      </span><span class="n">type_parameterized_test_registry_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The set holding the name of parameterized</span>
<span class="w">  </span><span class="c1">// test suites that may go uninstantiated.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ignored_parameterized_test_suites_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Indicates whether RegisterParameterizedTests() has been called already.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">parameterized_tests_registered_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Index of the last death test suite registered.  Initially -1.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">last_death_test_suite_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// This points to the TestSuite for the currently running test.  It</span>
<span class="w">  </span><span class="c1">// changes as Google Test goes through one test suite after another.</span>
<span class="w">  </span><span class="c1">// When no test is running, this is set to NULL and Google Test</span>
<span class="w">  </span><span class="c1">// stores assertion results in ad_hoc_test_result_.  Initially NULL.</span>
<span class="w">  </span><span class="n">TestSuite</span><span class="o">*</span><span class="w"> </span><span class="n">current_test_suite_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// This points to the TestInfo for the currently running test.  It</span>
<span class="w">  </span><span class="c1">// changes as Google Test goes through one test after another.  When</span>
<span class="w">  </span><span class="c1">// no test is running, this is set to NULL and Google Test stores</span>
<span class="w">  </span><span class="c1">// assertion results in ad_hoc_test_result_.  Initially NULL.</span>
<span class="w">  </span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="n">current_test_info_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Normally, a user only writes assertions inside a TEST or TEST_F,</span>
<span class="w">  </span><span class="c1">// or inside a function called by a TEST or TEST_F.  Since Google</span>
<span class="w">  </span><span class="c1">// Test keeps track of which test is current running, it can</span>
<span class="w">  </span><span class="c1">// associate such an assertion with the test it belongs to.</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// If an assertion is encountered when no TEST or TEST_F is running,</span>
<span class="w">  </span><span class="c1">// Google Test attributes the assertion result to an imaginary &quot;ad hoc&quot;</span>
<span class="w">  </span><span class="c1">// test, and records the result in ad_hoc_test_result_.</span>
<span class="w">  </span><span class="n">TestResult</span><span class="w"> </span><span class="n">ad_hoc_test_result_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The list of event listeners that can be used to track events inside</span>
<span class="w">  </span><span class="c1">// Google Test.</span>
<span class="w">  </span><span class="n">TestEventListeners</span><span class="w"> </span><span class="n">listeners_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The OS stack trace getter.  Will be deleted when the UnitTest</span>
<span class="w">  </span><span class="c1">// object is destructed.  By default, an OsStackTraceGetter is used,</span>
<span class="w">  </span><span class="c1">// but the user can set this field to use a custom getter if that is</span>
<span class="w">  </span><span class="c1">// desired.</span>
<span class="w">  </span><span class="n">OsStackTraceGetterInterface</span><span class="o">*</span><span class="w"> </span><span class="n">os_stack_trace_getter_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// True if and only if PostFlagParsingInit() has been called.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">post_flag_parse_init_performed_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The random number seed used at the beginning of the test run.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">random_seed_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Our random number generator.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">Random</span><span class="w"> </span><span class="n">random_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The time of the test program start, in ms from the start of the</span>
<span class="w">  </span><span class="c1">// UNIX epoch.</span>
<span class="w">  </span><span class="n">TimeInMillis</span><span class="w"> </span><span class="n">start_timestamp_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// How long the test took to run, in milliseconds.</span>
<span class="w">  </span><span class="n">TimeInMillis</span><span class="w"> </span><span class="n">elapsed_time_</span><span class="p">;</span>

<span class="cp">#ifdef GTEST_HAS_DEATH_TEST</span>
<span class="w">  </span><span class="c1">// The decomposed components of the gtest_internal_run_death_test flag,</span>
<span class="w">  </span><span class="c1">// parsed when RUN_ALL_TESTS is called.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InternalRunDeathTestFlag</span><span class="o">&gt;</span><span class="w"> </span><span class="n">internal_run_death_test_flag_</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">DeathTestFactory</span><span class="o">&gt;</span><span class="w"> </span><span class="n">death_test_factory_</span><span class="p">;</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_DEATH_TEST</span>

<span class="w">  </span><span class="c1">// A per-thread stack of traces created by the SCOPED_TRACE() macro.</span>
<span class="w">  </span><span class="n">internal</span><span class="o">::</span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TraceInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">gtest_trace_stack_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The value of GTEST_FLAG(catch_exceptions) at the moment RunAllTests()</span>
<span class="w">  </span><span class="c1">// starts.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">catch_exceptions_</span><span class="p">;</span>

<span class="w">  </span><span class="n">UnitTestImpl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTestImpl</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">UnitTestImpl</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTestImpl</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span><span class="w">  </span><span class="c1">// class UnitTestImpl</span>

<span class="c1">// Convenience function for accessing the global UnitTest</span>
<span class="c1">// implementation object.</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">UnitTestImpl</span><span class="o">*</span><span class="w"> </span><span class="nf">GetUnitTestImpl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">UnitTest</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef GTEST_USES_SIMPLE_RE</span>

<span class="c1">// Internal helper functions for implementing the simple regular</span>
<span class="c1">// expression matcher.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsInSet</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsAsciiDigit</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsAsciiPunct</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsRepeat</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsAsciiWhiteSpace</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsAsciiWordChar</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsValidEscape</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AtomMatchesChar</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">escaped</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ValidateRegex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">regex</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchRegexAtHead</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchRepetitionAndRegexAtHead</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">escaped</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">char</span><span class="w"> </span><span class="n">repeat</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">regex</span><span class="p">,</span>
<span class="w">                                              </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchRegexAnywhere</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="cp">#endif  </span><span class="c1">// GTEST_USES_SIMPLE_RE</span>

<span class="c1">// Parses the command line for Google Test flags, without initializing</span>
<span class="c1">// other parts of Google Test.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ParseGoogleTestFlagsOnly</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ParseGoogleTestFlagsOnly</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">wchar_t</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="cp">#ifdef GTEST_HAS_DEATH_TEST</span>

<span class="c1">// Returns the message describing the last system error, regardless of the</span>
<span class="c1">// platform.</span>
<span class="n">GTEST_API_</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">GetLastErrnoDescription</span><span class="p">();</span>

<span class="c1">// Attempts to parse a string into a positive integer pointed to by the</span>
<span class="c1">// number parameter.  Returns true if that is possible.</span>
<span class="c1">// GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we can use</span>
<span class="c1">// it here.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Integer</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">ParseNaturalNumber</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">*</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Fail fast if the given string does not begin with a digit;</span>
<span class="w">  </span><span class="c1">// this bypasses strtoXXX&#39;s &quot;optional leading whitespace and plus</span>
<span class="w">  </span><span class="c1">// or minus sign&quot; semantics, which are undesirable here.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">IsDigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// BiggestConvertible is the largest integer type that system-provided</span>
<span class="w">  </span><span class="c1">// string-to-number conversion routines can return.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BiggestConvertible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">;</span><span class="w">  </span><span class="c1">// NOLINT</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BiggestConvertible</span><span class="w"> </span><span class="n">parsed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtoull</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// NOLINT</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">parse_success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">end</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">errno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">parsed</span><span class="p">));</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">parsed</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parse_success</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BiggestConvertible</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">parsed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="c1">// GTEST_HAS_DEATH_TEST</span>

<span class="c1">// TestResult contains some private methods that should be hidden from</span>
<span class="c1">// Google Test user but are required for testing. This class allow our tests</span>
<span class="c1">// to access them.</span>
<span class="c1">//</span>
<span class="c1">// This class is supplied only for the purpose of testing Google Test&#39;s own</span>
<span class="c1">// constructs. Do not use it in user tests, either directly or indirectly.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TestResultAccessor</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">RecordProperty</span><span class="p">(</span><span class="n">TestResult</span><span class="o">*</span><span class="w"> </span><span class="n">test_result</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">xml_element</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">TestProperty</span><span class="o">&amp;</span><span class="w"> </span><span class="n">property</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">test_result</span><span class="o">-&gt;</span><span class="n">RecordProperty</span><span class="p">(</span><span class="n">xml_element</span><span class="p">,</span><span class="w"> </span><span class="n">property</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ClearTestPartResults</span><span class="p">(</span><span class="n">TestResult</span><span class="o">*</span><span class="w"> </span><span class="n">test_result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">test_result</span><span class="o">-&gt;</span><span class="n">ClearTestPartResults</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">testing</span><span class="o">::</span><span class="n">TestPartResult</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">test_part_results</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">TestResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">test_result</span><span class="p">.</span><span class="n">test_part_results</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="cp">#if GTEST_CAN_STREAM_RESULTS_</span>

<span class="c1">// Streams test results to the given port on the given host machine.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StreamingListener</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EmptyTestEventListener</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Abstract base class for writing strings to a socket.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AbstractSocketWriter</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">AbstractSocketWriter</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sends a string to the socket.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Send</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Closes the socket.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">CloseConnection</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Sends a string and a newline to the socket.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">SendLn</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Send</span><span class="p">(</span><span class="n">message</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Concrete class for actually writing strings to a socket.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">SocketWriter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">AbstractSocketWriter</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">SocketWriter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">port</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">sockfd_</span><span class="p">(</span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">host_name_</span><span class="p">(</span><span class="n">host</span><span class="p">),</span><span class="w"> </span><span class="n">port_num_</span><span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">MakeConnection</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">~</span><span class="n">SocketWriter</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sockfd_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">CloseConnection</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Sends a string to the socket.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Send</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="n">sockfd_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Send() can be called only when there is a connection.&quot;</span><span class="p">;</span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">ssize_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">len</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">GTEST_LOG_</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stream_result_to: failed to stream to &quot;</span>
<span class="w">                            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">host_name_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">port_num_</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">   </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Creates a client socket and connects to the server.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">MakeConnection</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Closes the socket.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">CloseConnection</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">GTEST_CHECK_</span><span class="p">(</span><span class="n">sockfd_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CloseConnection() can be called only when there is a connection.&quot;</span><span class="p">;</span>

<span class="w">      </span><span class="n">close</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">);</span>
<span class="w">      </span><span class="n">sockfd_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sockfd_</span><span class="p">;</span><span class="w">  </span><span class="c1">// socket file descriptor</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">host_name_</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">port_num_</span><span class="p">;</span>

<span class="w">    </span><span class="n">SocketWriter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SocketWriter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">SocketWriter</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SocketWriter</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span><span class="w">  </span><span class="c1">// class SocketWriter</span>

<span class="w">  </span><span class="c1">// Escapes &#39;=&#39;, &#39;&amp;&#39;, &#39;%&#39;, and &#39;\n&#39; characters in str as &quot;%xx&quot;.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">UrlEncode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="w">  </span><span class="n">StreamingListener</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">port</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">socket_writer_</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">SocketWriter</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Start</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">StreamingListener</span><span class="p">(</span><span class="n">AbstractSocketWriter</span><span class="o">*</span><span class="w"> </span><span class="n">socket_writer</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">socket_writer_</span><span class="p">(</span><span class="n">socket_writer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Start</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestProgramStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTest</span><span class="o">&amp;</span><span class="w"> </span><span class="cm">/* unit_test */</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestProgramStart&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestProgramEnd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTest</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unit_test</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Note that Google Test current only report elapsed time for each</span>
<span class="w">    </span><span class="c1">// test iteration, not for the entire test program.</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestProgramEnd&amp;passed=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FormatBool</span><span class="p">(</span><span class="n">unit_test</span><span class="p">.</span><span class="n">Passed</span><span class="p">()));</span>

<span class="w">    </span><span class="c1">// Notify the streaming server to stop.</span>
<span class="w">    </span><span class="n">socket_writer_</span><span class="o">-&gt;</span><span class="n">CloseConnection</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestIterationStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTest</span><span class="o">&amp;</span><span class="w"> </span><span class="cm">/* unit_test */</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestIterationStart&amp;iteration=&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="n">StreamableToString</span><span class="p">(</span><span class="n">iteration</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestIterationEnd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UnitTest</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unit_test</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="cm">/* iteration */</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestIterationEnd&amp;passed=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FormatBool</span><span class="p">(</span><span class="n">unit_test</span><span class="p">.</span><span class="n">Passed</span><span class="p">())</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;&amp;elapsed_time=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">StreamableToString</span><span class="p">(</span><span class="n">unit_test</span><span class="p">.</span><span class="n">elapsed_time</span><span class="p">())</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;ms&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Note that &quot;event=TestCaseStart&quot; is a wire format and has to remain</span>
<span class="w">  </span><span class="c1">// &quot;case&quot; for compatibility</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestSuiteStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_suite</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;event=TestCaseStart&amp;name=&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">test_suite</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Note that &quot;event=TestCaseEnd&quot; is a wire format and has to remain</span>
<span class="w">  </span><span class="c1">// &quot;case&quot; for compatibility</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestSuiteEnd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestSuite</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_suite</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestCaseEnd&amp;passed=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FormatBool</span><span class="p">(</span><span class="n">test_suite</span><span class="p">.</span><span class="n">Passed</span><span class="p">())</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;&amp;elapsed_time=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">StreamableToString</span><span class="p">(</span><span class="n">test_suite</span><span class="p">.</span><span class="n">elapsed_time</span><span class="p">())</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;ms&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_info</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;event=TestStart&amp;name=&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">test_info</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestEnd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_info</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestEnd&amp;passed=&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="n">FormatBool</span><span class="p">((</span><span class="n">test_info</span><span class="p">.</span><span class="n">result</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">Passed</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;&amp;elapsed_time=&quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="n">StreamableToString</span><span class="p">((</span><span class="n">test_info</span><span class="p">.</span><span class="n">result</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">elapsed_time</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;ms&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnTestPartResult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TestPartResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_part_result</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_part_result</span><span class="p">.</span><span class="n">file_name</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="n">file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;event=TestPartResult&amp;file=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UrlEncode</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;&amp;line=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">StreamableToString</span><span class="p">(</span><span class="n">test_part_result</span><span class="p">.</span><span class="n">line_number</span><span class="p">())</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;&amp;message=&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UrlEncode</span><span class="p">(</span><span class="n">test_part_result</span><span class="p">.</span><span class="n">message</span><span class="p">()));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Sends the given message and a newline to the socket.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SendLn</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">socket_writer_</span><span class="o">-&gt;</span><span class="n">SendLn</span><span class="p">(</span><span class="n">message</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Called at the start of streaming to notify the receiver what</span>
<span class="w">  </span><span class="c1">// protocol we are using.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Start</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SendLn</span><span class="p">(</span><span class="s">&quot;gtest_streaming_protocol_version=1.0&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FormatBool</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;0&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractSocketWriter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket_writer_</span><span class="p">;</span>

<span class="w">  </span><span class="n">StreamingListener</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StreamingListener</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">  </span><span class="n">StreamingListener</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StreamingListener</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span><span class="w">  </span><span class="c1">// class StreamingListener</span>

<span class="cp">#endif  </span><span class="c1">// GTEST_CAN_STREAM_RESULTS_</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace internal</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace testing</span>

<span class="n">GTEST_DISABLE_MSC_WARNINGS_POP_</span><span class="p">()</span><span class="w">  </span><span class="c1">//  4251</span>

<span class="cp">#endif  </span><span class="c1">// GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2024, Wageningen University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #D0F1C6; */
    }
    /* Sidebar */
    .wy-nav-side {
      /* background: #ff0000; */
    }
  </style>


</body>
</html>