

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File faq.md &mdash; Fields2Cover latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../_static/code-tabs.css?v=1bc26e2f" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://fields2cover.github.io/api/program_listing_file_googletest_docs_faq.md.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/code-tabs.js?v=c983d12e"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo_fields2cover.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Fields2Cover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/migration_to_v2.html">Migration guide to version 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="f2c_library.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Fields2Cover</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File faq.md</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_googletest_docs_faq.md.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-faq-md">
<span id="program-listing-file-googletest-docs-faq-md"></span><h1>Program Listing for File faq.md<a class="headerlink" href="#program-listing-for-file-faq-md" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_googletest_docs_faq.md.html#file-googletest-docs-faq-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">googletest/docs/faq.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span><span class="gh"># GoogleTest FAQ</span>

<span class="gu">## Why should test suite names and test names not contain underscore?</span>

{: .callout .note}
Note: GoogleTest reserves underscore (<span class="sb">`_`</span>) for special-purpose keywords, such as
[<span class="nt">the `DISABLED_` prefix</span>](<span class="na">advanced.md#temporarily-disabling-tests</span>), in addition
to the following rationale.

Underscore (<span class="sb">`_`</span>) is special, as C++ reserves the following to be used by the
compiler and the standard library:

<span class="k">1.</span>  any identifier that starts with an <span class="sb">`_`</span> followed by an upper-case letter, and
<span class="k">2.</span>  any identifier that contains two consecutive underscores (i.e. <span class="sb">`__`</span>)
    <span class="ge">*anywhere*</span> in its name.

User code is <span class="ge">*prohibited*</span> from using such identifiers.

Now let&#39;s look at what this means for <span class="sb">`TEST`</span> and <span class="sb">`TEST_F`</span>.

Currently <span class="sb">`TEST(TestSuiteName, TestName)`</span> generates a class named
<span class="sb">`TestSuiteName_TestName_Test`</span>. What happens if <span class="sb">`TestSuiteName`</span> or <span class="sb">`TestName`</span>
contains <span class="sb">`_`</span>?

<span class="k">1.</span>  If <span class="sb">`TestSuiteName`</span> starts with an <span class="sb">`_`</span> followed by an upper-case letter (say,
    <span class="sb">`_Foo`</span>), we end up with <span class="sb">`_Foo_TestName_Test`</span>, which is reserved and thus
    invalid.
<span class="k">2.</span>  If <span class="sb">`TestSuiteName`</span> ends with an <span class="sb">`_`</span> (say, <span class="sb">`Foo_`</span>), we get
    <span class="sb">`Foo__TestName_Test`</span>, which is invalid.
<span class="k">3.</span>  If <span class="sb">`TestName`</span> starts with an <span class="sb">`_`</span> (say, <span class="sb">`_Bar`</span>), we get
    <span class="sb">`TestSuiteName__Bar_Test`</span>, which is invalid.
<span class="k">4.</span>  If <span class="sb">`TestName`</span> ends with an <span class="sb">`_`</span> (say, <span class="sb">`Bar_`</span>), we get
    <span class="sb">`TestSuiteName_Bar__Test`</span>, which is invalid.

So clearly <span class="sb">`TestSuiteName`</span> and <span class="sb">`TestName`</span> cannot start or end with <span class="sb">`_`</span>
(Actually, <span class="sb">`TestSuiteName`</span> can start with <span class="sb">`_`</span>—as long as the <span class="sb">`_`</span> isn&#39;t followed
by an upper-case letter. But that&#39;s getting complicated. So for simplicity we
just say that it cannot start with <span class="sb">`_`</span>.).

It may seem fine for <span class="sb">`TestSuiteName`</span> and <span class="sb">`TestName`</span> to contain <span class="sb">`_`</span> in the
middle. However, consider this:

```c++
TEST(Time, Flies_Like_An_Arrow) { ... }
TEST(Time_Flies, Like_An_Arrow) { ... }
<span class="sb">```</span>

<span class="sb">Now, the two `TEST`s will both generate the same class</span>
<span class="sb">(`Time_Flies_Like_An_Arrow_Test`). That&#39;s not good.</span>

<span class="sb">So for simplicity, we just ask the users to avoid `_` in `TestSuiteName` and</span>
<span class="sb">`TestName`. The rule is more constraining than necessary, but it&#39;s simple and</span>
<span class="sb">easy to remember. It also gives GoogleTest some wiggle room in case its</span>
<span class="sb">implementation needs to change in the future.</span>

<span class="sb">If you violate the rule, there may not be immediate consequences, but your test</span>
<span class="sb">may (just may) break with a new compiler (or a new version of the compiler you</span>
<span class="sb">are using) or with a new version of GoogleTest. Therefore it&#39;s best to follow</span>
<span class="sb">the rule.</span>

<span class="sb">## Why does GoogleTest support `EXPECT_EQ(NULL, ptr)` and `ASSERT_EQ(NULL, ptr)` but not `EXPECT_NE(NULL, ptr)` and `ASSERT_NE(NULL, ptr)`?</span>

<span class="sb">First of all, you can use `nullptr` with each of these macros, e.g.</span>
<span class="sb">`EXPECT_EQ(ptr, nullptr)`, `EXPECT_NE(ptr, nullptr)`, `ASSERT_EQ(ptr, nullptr)`,</span>
<span class="sb">`ASSERT_NE(ptr, nullptr)`. This is the preferred syntax in the style guide</span>
<span class="sb">because `nullptr` does not have the type problems that `NULL` does.</span>

<span class="sb">Due to some peculiarity of C++, it requires some non-trivial template meta</span>
<span class="sb">programming tricks to support using `NULL` as an argument of the `EXPECT_XX()`</span>
<span class="sb">and `ASSERT_XX()` macros. Therefore we only do it where it&#39;s most needed</span>
<span class="sb">(otherwise we make the implementation of GoogleTest harder to maintain and more</span>
<span class="sb">error-prone than necessary).</span>

<span class="sb">Historically, the `EXPECT_EQ()` macro took the *expected* value as its first</span>
<span class="sb">argument and the *actual* value as the second, though this argument order is now</span>
<span class="sb">discouraged. It was reasonable that someone wanted</span>
<span class="sb">to write `EXPECT_EQ(NULL, some_expression)`, and this indeed was requested</span>
<span class="sb">several times. Therefore we implemented it.</span>

<span class="sb">The need for `EXPECT_NE(NULL, ptr)` wasn&#39;t nearly as strong. When the assertion</span>
<span class="sb">fails, you already know that `ptr` must be `NULL`, so it doesn&#39;t add any</span>
<span class="sb">information to print `ptr` in this case. That means `EXPECT_TRUE(ptr != NULL)`</span>
<span class="sb">works just as well.</span>

<span class="sb">If we were to support `EXPECT_NE(NULL, ptr)`, for consistency we&#39;d have to</span>
<span class="sb">support `EXPECT_NE(ptr, NULL)` as well. This means using the template meta</span>
<span class="sb">programming tricks twice in the implementation, making it even harder to</span>
<span class="sb">understand and maintain. We believe the benefit doesn&#39;t justify the cost.</span>

<span class="sb">Finally, with the growth of the gMock matcher library, we are encouraging people</span>
<span class="sb">to use the unified `EXPECT_THAT(value, matcher)` syntax more often in tests. One</span>
<span class="sb">significant advantage of the matcher approach is that matchers can be easily</span>
<span class="sb">combined to form new matchers, while the `EXPECT_NE`, etc, macros cannot be</span>
<span class="sb">easily combined. Therefore we want to invest more in the matchers than in the</span>
<span class="sb">`EXPECT_XX()` macros.</span>

<span class="sb">## I need to test that different implementations of an interface satisfy some common requirements. Should I use typed tests or value-parameterized tests?</span>

<span class="sb">For testing various implementations of the same interface, either typed tests or</span>
<span class="sb">value-parameterized tests can get it done. It&#39;s really up to you the user to</span>
<span class="sb">decide which is more convenient for you, depending on your particular case. Some</span>
<span class="sb">rough guidelines:</span>

<span class="sb">*   Typed tests can be easier to write if instances of the different</span>
<span class="sb">    implementations can be created the same way, modulo the type. For example,</span>
<span class="sb">    if all these implementations have a public default constructor (such that</span>
<span class="sb">    you can write `new TypeParam`), or if their factory functions have the same</span>
<span class="sb">    form (e.g. `CreateInstance&lt;TypeParam&gt;()`).</span>
<span class="sb">*   Value-parameterized tests can be easier to write if you need different code</span>
<span class="sb">    patterns to create different implementations&#39; instances, e.g. `new Foo` vs</span>
<span class="sb">    `new Bar(5)`. To accommodate for the differences, you can write factory</span>
<span class="sb">    function wrappers and pass these function pointers to the tests as their</span>
<span class="sb">    parameters.</span>
<span class="sb">*   When a typed test fails, the default output includes the name of the type,</span>
<span class="sb">    which can help you quickly identify which implementation is wrong.</span>
<span class="sb">    Value-parameterized tests only show the number of the failed iteration by</span>
<span class="sb">    default. You will need to define a function that returns the iteration name</span>
<span class="sb">    and pass it as the third parameter to INSTANTIATE_TEST_SUITE_P to have more</span>
<span class="sb">    useful output.</span>
<span class="sb">*   When using typed tests, you need to make sure you are testing against the</span>
<span class="sb">    interface type, not the concrete types (in other words, you want to make</span>
<span class="sb">    sure `implicit_cast&lt;MyInterface*&gt;(my_concrete_impl)` works, not just that</span>
<span class="sb">    `my_concrete_impl` works). It&#39;s less likely to make mistakes in this area</span>
<span class="sb">    when using value-parameterized tests.</span>

<span class="sb">I hope I didn&#39;t confuse you more. :-) If you don&#39;t mind, I&#39;d suggest you to give</span>
<span class="sb">both approaches a try. Practice is a much better way to grasp the subtle</span>
<span class="sb">differences between the two tools. Once you have some concrete experience, you</span>
<span class="sb">can much more easily decide which one to use the next time.</span>

<span class="sb">## My death test modifies some state, but the change seems lost after the death test finishes. Why?</span>

<span class="sb">Death tests (`EXPECT_DEATH`, etc.) are executed in a sub-process s.t. the</span>
<span class="sb">expected crash won&#39;t kill the test program (i.e. the parent process). As a</span>
<span class="sb">result, any in-memory side effects they incur are observable in their respective</span>
<span class="sb">sub-processes, but not in the parent process. You can think of them as running</span>
<span class="sb">in a parallel universe, more or less.</span>

<span class="sb">In particular, if you use mocking and the death test statement invokes some mock</span>
<span class="sb">methods, the parent process will think the calls have never occurred. Therefore,</span>
<span class="sb">you may want to move your `EXPECT_CALL` statements inside the `EXPECT_DEATH`</span>
<span class="sb">macro.</span>

<span class="sb">## EXPECT_EQ(htonl(blah), blah_blah) generates weird compiler errors in opt mode. Is this a GoogleTest bug?</span>

<span class="sb">Actually, the bug is in `htonl()`.</span>

<span class="sb">According to `&#39;man htonl&#39;`, `htonl()` is a *function*, which means it&#39;s valid to</span>
<span class="sb">use `htonl` as a function pointer. However, in opt mode `htonl()` is defined as</span>
<span class="sb">a *macro*, which breaks this usage.</span>

<span class="sb">Worse, the macro definition of `htonl()` uses a `gcc` extension and is *not*</span>
<span class="sb">standard C++. That hacky implementation has some ad hoc limitations. In</span>
<span class="sb">particular, it prevents you from writing `Foo&lt;sizeof(htonl(x))&gt;()`, where `Foo`</span>
<span class="sb">is a template that has an integral argument.</span>

<span class="sb">The implementation of `EXPECT_EQ(a, b)` uses `sizeof(... a ...)` inside a</span>
<span class="sb">template argument, and thus doesn&#39;t compile in opt mode when `a` contains a call</span>
<span class="sb">to `htonl()`. It is difficult to make `EXPECT_EQ` bypass the `htonl()` bug, as</span>
<span class="sb">the solution must work with different compilers on various platforms.</span>

<span class="sb">## The compiler complains about &quot;undefined references&quot; to some static const member variables, but I did define them in the class body. What&#39;s wrong?</span>

<span class="sb">If your class has a static data member:</span>

<span class="sb">```c++</span>
<span class="sb">// foo.h</span>
<span class="sb">class Foo {</span>
<span class="sb">  ...</span>
<span class="sb">  static const int kBar = 100;</span>
<span class="sb">};</span>
<span class="sb">```</span>

you also need to define it <span class="ge">*outside*</span> of the class body in <span class="sb">`foo.cc`</span>:

```c++
const int Foo::kBar;  // No initializer here.
<span class="sb">```</span>

<span class="sb">Otherwise your code is **invalid C++**, and may break in unexpected ways. In</span>
<span class="sb">particular, using it in GoogleTest comparison assertions (`EXPECT_EQ`, etc.)</span>
<span class="sb">will generate an &quot;undefined reference&quot; linker error. The fact that &quot;it used to</span>
<span class="sb">work&quot; doesn&#39;t mean it&#39;s valid. It just means that you were lucky. :-)</span>

<span class="sb">If the declaration of the static data member is `constexpr` then it is</span>
<span class="sb">implicitly an `inline` definition, and a separate definition in `foo.cc` is not</span>
<span class="sb">needed:</span>

<span class="sb">```c++</span>
<span class="sb">// foo.h</span>
<span class="sb">class Foo {</span>
<span class="sb">  ...</span>
<span class="sb">  static constexpr int kBar = 100;  // Defines kBar, no need to do it in foo.cc.</span>
<span class="sb">};</span>
<span class="sb">```</span>

<span class="gu">## Can I derive a test fixture from another?</span>

Yes.

Each test fixture has a corresponding and same named test suite. This means only
one test suite can use a particular fixture. Sometimes, however, multiple test
cases may want to use the same or slightly different fixtures. For example, you
may want to make sure that all of a GUI library&#39;s test suites don&#39;t leak
important system resources like fonts and brushes.

In GoogleTest, you share a fixture among test suites by putting the shared logic
in a base test fixture, then deriving from that base a separate fixture for each
test suite that wants to use this common logic. You then use <span class="sb">`TEST_F()`</span> to write
tests using each derived fixture.

Typically, your code looks like this:

```c++
// Defines a base test fixture.
class BaseTest : public ::testing::Test {
 protected:
  ...
};

// Derives a fixture FooTest from BaseTest.
class FooTest : public BaseTest {
 protected:
  void SetUp() override {
    BaseTest::SetUp();  // Sets up the base fixture first.
    ... additional set-up work ...
  }

  void TearDown() override {
    ... clean-up work for FooTest ...
    BaseTest::TearDown();  // Remember to tear down the base fixture
                           // after cleaning up FooTest!
  }

  ... functions and variables for FooTest ...
};

// Tests that use the fixture FooTest.
TEST_F(FooTest, Bar) { ... }
TEST_F(FooTest, Baz) { ... }

... additional fixtures derived from BaseTest ...
<span class="sb">```</span>

<span class="sb">If necessary, you can continue to derive test fixtures from a derived fixture.</span>
<span class="sb">GoogleTest has no limit on how deep the hierarchy can be.</span>

<span class="sb">For a complete example using derived test fixtures, see</span>
<span class="sb">[sample5_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample5_unittest.cc).</span>

<span class="sb">## My compiler complains &quot;void value not ignored as it ought to be.&quot; What does this mean?</span>

<span class="sb">You&#39;re probably using an `ASSERT_*()` in a function that doesn&#39;t return `void`.</span>
<span class="sb">`ASSERT_*()` can only be used in `void` functions, due to exceptions being</span>
<span class="sb">disabled by our build system. Please see more details</span>
<span class="sb">[here](advanced.md#assertion-placement).</span>

<span class="sb">## My death test hangs (or seg-faults). How do I fix it?</span>

<span class="sb">In GoogleTest, death tests are run in a child process and the way they work is</span>
<span class="sb">delicate. To write death tests you really need to understand how they work—see</span>
<span class="sb">the details at [Death Assertions](reference/assertions.md#death) in the</span>
<span class="sb">Assertions Reference.</span>

<span class="sb">In particular, death tests don&#39;t like having multiple threads in the parent</span>
<span class="sb">process. So the first thing you can try is to eliminate creating threads outside</span>
<span class="sb">of `EXPECT_DEATH()`. For example, you may want to use mocks or fake objects</span>
<span class="sb">instead of real ones in your tests.</span>

<span class="sb">Sometimes this is impossible as some library you must use may be creating</span>
<span class="sb">threads before `main()` is even reached. In this case, you can try to minimize</span>
<span class="sb">the chance of conflicts by either moving as many activities as possible inside</span>
<span class="sb">`EXPECT_DEATH()` (in the extreme case, you want to move everything inside), or</span>
<span class="sb">leaving as few things as possible in it. Also, you can try to set the death test</span>
<span class="sb">style to `&quot;threadsafe&quot;`, which is safer but slower, and see if it helps.</span>

<span class="sb">If you go with thread-safe death tests, remember that they rerun the test</span>
<span class="sb">program from the beginning in the child process. Therefore make sure your</span>
<span class="sb">program can run side-by-side with itself and is deterministic.</span>

<span class="sb">In the end, this boils down to good concurrent programming. You have to make</span>
<span class="sb">sure that there are no race conditions or deadlocks in your program. No silver</span>
<span class="sb">bullet - sorry!</span>

<span class="sb">## Should I use the constructor/destructor of the test fixture or SetUp()/TearDown()? {#CtorVsSetUp}</span>

<span class="sb">The first thing to remember is that GoogleTest does **not** reuse the same test</span>
<span class="sb">fixture object across multiple tests. For each `TEST_F`, GoogleTest will create</span>
<span class="sb">a **fresh** test fixture object, immediately call `SetUp()`, run the test body,</span>
<span class="sb">call `TearDown()`, and then delete the test fixture object.</span>

<span class="sb">When you need to write per-test set-up and tear-down logic, you have the choice</span>
<span class="sb">between using the test fixture constructor/destructor or `SetUp()`/`TearDown()`.</span>
<span class="sb">The former is usually preferred, as it has the following benefits:</span>

<span class="sb">*   By initializing a member variable in the constructor, we have the option to</span>
<span class="sb">    make it `const`, which helps prevent accidental changes to its value and</span>
<span class="sb">    makes the tests more obviously correct.</span>
<span class="sb">*   In case we need to subclass the test fixture class, the subclass&#39;</span>
<span class="sb">    constructor is guaranteed to call the base class&#39; constructor *first*, and</span>
<span class="sb">    the subclass&#39; destructor is guaranteed to call the base class&#39; destructor</span>
<span class="sb">    *afterward*. With `SetUp()/TearDown()`, a subclass may make the mistake of</span>
<span class="sb">    forgetting to call the base class&#39; `SetUp()/TearDown()` or call them at the</span>
<span class="sb">    wrong time.</span>

<span class="sb">You may still want to use `SetUp()/TearDown()` in the following cases:</span>

<span class="sb">*   C++ does not allow virtual function calls in constructors and destructors.</span>
<span class="sb">    You can call a method declared as virtual, but it will not use dynamic</span>
<span class="sb">    dispatch. It will use the definition from the class the constructor of which</span>
<span class="sb">    is currently executing. This is because calling a virtual method before the</span>
<span class="sb">    derived class constructor has a chance to run is very dangerous - the</span>
<span class="sb">    virtual method might operate on uninitialized data. Therefore, if you need</span>
<span class="sb">    to call a method that will be overridden in a derived class, you have to use</span>
<span class="sb">    `SetUp()/TearDown()`.</span>
<span class="sb">*   In the body of a constructor (or destructor), it&#39;s not possible to use the</span>
<span class="sb">    `ASSERT_xx` macros. Therefore, if the set-up operation could cause a fatal</span>
<span class="sb">    test failure that should prevent the test from running, it&#39;s necessary to</span>
<span class="sb">    use `abort` and abort the whole test</span>
<span class="sb">    executable, or to use `SetUp()` instead of a constructor.</span>
<span class="sb">*   If the tear-down operation could throw an exception, you must use</span>
<span class="sb">    `TearDown()` as opposed to the destructor, as throwing in a destructor leads</span>
<span class="sb">    to undefined behavior and usually will kill your program right away. Note</span>
<span class="sb">    that many standard libraries (like STL) may throw when exceptions are</span>
<span class="sb">    enabled in the compiler. Therefore you should prefer `TearDown()` if you</span>
<span class="sb">    want to write portable tests that work with or without exceptions.</span>
<span class="sb">*   The GoogleTest team is considering making the assertion macros throw on</span>
<span class="sb">    platforms where exceptions are enabled (e.g. Windows, Mac OS, and Linux</span>
<span class="sb">    client-side), which will eliminate the need for the user to propagate</span>
<span class="sb">    failures from a subroutine to its caller. Therefore, you shouldn&#39;t use</span>
<span class="sb">    GoogleTest assertions in a destructor if your code could run on such a</span>
<span class="sb">    platform.</span>

<span class="sb">## The compiler complains &quot;no matching function to call&quot; when I use `ASSERT_PRED*`. How do I fix it?</span>

<span class="sb">See details for [`EXPECT_PRED*`](reference/assertions.md#EXPECT_PRED) in the</span>
<span class="sb">Assertions Reference.</span>

<span class="sb">## My compiler complains about &quot;ignoring return value&quot; when I call RUN_ALL_TESTS(). Why?</span>

<span class="sb">Some people had been ignoring the return value of `RUN_ALL_TESTS()`. That is,</span>
<span class="sb">instead of</span>

<span class="sb">```c++</span>
<span class="sb">  return RUN_ALL_TESTS();</span>
<span class="sb">```</span>

they write

```c++
  RUN_ALL_TESTS();
<span class="sb">```</span>

<span class="sb">This is **wrong and dangerous**. The testing services needs to see the return</span>
<span class="sb">value of `RUN_ALL_TESTS()` in order to determine if a test has passed. If your</span>
<span class="sb">`main()` function ignores it, your test will be considered successful even if it</span>
<span class="sb">has a GoogleTest assertion failure. Very bad.</span>

<span class="sb">We have decided to fix this (thanks to Michael Chastain for the idea). Now, your</span>
<span class="sb">code will no longer be able to ignore `RUN_ALL_TESTS()` when compiled with</span>
<span class="sb">`gcc`. If you do so, you&#39;ll get a compiler error.</span>

<span class="sb">If you see the compiler complaining about you ignoring the return value of</span>
<span class="sb">`RUN_ALL_TESTS()`, the fix is simple: just make sure its value is used as the</span>
<span class="sb">return value of `main()`.</span>

<span class="sb">But how could we introduce a change that breaks existing tests? Well, in this</span>
<span class="sb">case, the code was already broken in the first place, so we didn&#39;t break it. :-)</span>

<span class="sb">## My compiler complains that a constructor (or destructor) cannot return a value. What&#39;s going on?</span>

<span class="sb">Due to a peculiarity of C++, in order to support the syntax for streaming</span>
<span class="sb">messages to an `ASSERT_*`, e.g.</span>

<span class="sb">```c++</span>
<span class="sb">  ASSERT_EQ(1, Foo()) &lt;&lt; &quot;blah blah&quot; &lt;&lt; foo;</span>
<span class="sb">```</span>

we had to give up using <span class="sb">`ASSERT*`</span> and <span class="sb">`FAIL*`</span> (but not <span class="sb">`EXPECT*`</span> and
<span class="sb">`ADD_FAILURE*`</span>) in constructors and destructors. The workaround is to move the
content of your constructor/destructor to a private void member function, or
switch to <span class="sb">`EXPECT_*()`</span> if that works. This
[<span class="nt">section</span>](<span class="na">advanced.md#assertion-placement</span>) in the user&#39;s guide explains it.

<span class="gu">## My SetUp() function is not called. Why?</span>

C++ is case-sensitive. Did you spell it as <span class="sb">`Setup()`</span>?

Similarly, sometimes people spell <span class="sb">`SetUpTestSuite()`</span> as <span class="sb">`SetupTestSuite()`</span> and
wonder why it&#39;s never called.

<span class="gu">## I have several test suites which share the same test fixture logic; do I have to define a new test fixture class for each of them? This seems pretty tedious.</span>

You don&#39;t have to. Instead of

```c++
class FooTest : public BaseTest {};

TEST_F(FooTest, Abc) { ... }
TEST_F(FooTest, Def) { ... }

class BarTest : public BaseTest {};

TEST_F(BarTest, Abc) { ... }
TEST_F(BarTest, Def) { ... }
<span class="sb">```</span>

<span class="sb">you can simply `typedef` the test fixtures:</span>

<span class="sb">```c++</span>
<span class="sb">typedef BaseTest FooTest;</span>

<span class="sb">TEST_F(FooTest, Abc) { ... }</span>
<span class="sb">TEST_F(FooTest, Def) { ... }</span>

<span class="sb">typedef BaseTest BarTest;</span>

<span class="sb">TEST_F(BarTest, Abc) { ... }</span>
<span class="sb">TEST_F(BarTest, Def) { ... }</span>
<span class="sb">```</span>

<span class="gu">## GoogleTest output is buried in a whole bunch of LOG messages. What do I do?</span>

The GoogleTest output is meant to be a concise and human-friendly report. If
your test generates textual output itself, it will mix with the GoogleTest
output, making it hard to read. However, there is an easy solution to this
problem.

Since <span class="sb">`LOG`</span> messages go to stderr, we decided to let GoogleTest output go to
stdout. This way, you can easily separate the two using redirection. For
example:

<span class="sb">```shell</span>
$<span class="w"> </span>./my_test<span class="w"> </span>&gt;<span class="w"> </span>gtest_output.txt
<span class="sb">```</span>

<span class="gu">## Why should I prefer test fixtures over global variables?</span>

There are several good reasons:

<span class="k">1.</span>  It&#39;s likely your test needs to change the states of its global variables.
    This makes it difficult to keep side effects from escaping one test and
    contaminating others, making debugging difficult. By using fixtures, each
    test has a fresh set of variables that&#39;s different (but with the same
    names). Thus, tests are kept independent of each other.
<span class="k">2.</span>  Global variables pollute the global namespace.
<span class="k">3.</span>  Test fixtures can be reused via subclassing, which cannot be done easily
    with global variables. This is useful if many test suites have something in
    common.

<span class="gu">## What can the statement argument in ASSERT_DEATH() be?</span>

<span class="sb">`ASSERT_DEATH(statement, matcher)`</span> (or any death assertion macro) can be used
wherever <span class="ge">*`statement`*</span> is valid. So basically <span class="ge">*`statement`*</span> can be any C++
statement that makes sense in the current context. In particular, it can
reference global and/or local variables, and can be:

<span class="k">*</span><span class="w"> </span>  a simple function call (often the case),
<span class="k">*</span><span class="w"> </span>  a complex expression, or
<span class="k">*</span><span class="w"> </span>  a compound statement.

Some examples are shown here:

```c++
// A death test can be a simple function call.
TEST(MyDeathTest, FunctionCall) {
  ASSERT_DEATH(Xyz(5), &quot;Xyz failed&quot;);
}

// Or a complex expression that references variables and functions.
TEST(MyDeathTest, ComplexExpression) {
  const bool c = Condition();
  ASSERT_DEATH((c ? Func1(0) : object2.Method(&quot;test&quot;)),
               &quot;(Func1|Method) failed&quot;);
}

// Death assertions can be used anywhere in a function.  In
// particular, they can be inside a loop.
TEST(MyDeathTest, InsideLoop) {
  // Verifies that Foo(0), Foo(1), ..., and Foo(4) all die.
  for (int i = 0; i &lt; 5; i++) {
    EXPECT_DEATH_M(Foo(i), &quot;Foo has \\d+ errors&quot;,
                   ::testing::Message() &lt;&lt; &quot;where i is &quot; &lt;&lt; i);
  }
}

// A death assertion can contain a compound statement.
TEST(MyDeathTest, CompoundStatement) {
  // Verifies that at lease one of Bar(0), Bar(1), ..., and
  // Bar(4) dies.
  ASSERT_DEATH({
    for (int i = 0; i &lt; 5; i++) {
      Bar(i);
    }
  },
  &quot;Bar has \\d+ errors&quot;);
}
<span class="sb">```</span>

<span class="sb">## I have a fixture class `FooTest`, but `TEST_F(FooTest, Bar)` gives me error ``&quot;no matching function for call to `FooTest::FooTest()&#39;&quot;``. Why?</span>

<span class="sb">GoogleTest needs to be able to create objects of your test fixture class, so it</span>
<span class="sb">must have a default constructor. Normally the compiler will define one for you.</span>
<span class="sb">However, there are cases where you have to define your own:</span>

<span class="sb">*   If you explicitly declare a non-default constructor for class `FooTest`</span>
<span class="sb">    (`DISALLOW_EVIL_CONSTRUCTORS()` does this), then you need to define a</span>
<span class="sb">    default constructor, even if it would be empty.</span>
<span class="sb">*   If `FooTest` has a const non-static data member, then you have to define the</span>
<span class="sb">    default constructor *and* initialize the const member in the initializer</span>
<span class="sb">    list of the constructor. (Early versions of `gcc` doesn&#39;t force you to</span>
<span class="sb">    initialize the const member. It&#39;s a bug that has been fixed in `gcc 4`.)</span>

<span class="sb">## Why does ASSERT_DEATH complain about previous threads that were already joined?</span>

<span class="sb">With the Linux pthread library, there is no turning back once you cross the line</span>
<span class="sb">from a single thread to multiple threads. The first time you create a thread, a</span>
<span class="sb">manager thread is created in addition, so you get 3, not 2, threads. Later when</span>
<span class="sb">the thread you create joins the main thread, the thread count decrements by 1,</span>
<span class="sb">but the manager thread will never be killed, so you still have 2 threads, which</span>
<span class="sb">means you cannot safely run a death test.</span>

<span class="sb">The new NPTL thread library doesn&#39;t suffer from this problem, as it doesn&#39;t</span>
<span class="sb">create a manager thread. However, if you don&#39;t control which machine your test</span>
<span class="sb">runs on, you shouldn&#39;t depend on this.</span>

<span class="sb">## Why does GoogleTest require the entire test suite, instead of individual tests, to be named `*DeathTest` when it uses `ASSERT_DEATH`?</span>

<span class="sb">GoogleTest does not interleave tests from different test suites. That is, it</span>
<span class="sb">runs all tests in one test suite first, and then runs all tests in the next test</span>
<span class="sb">suite, and so on. GoogleTest does this because it needs to set up a test suite</span>
<span class="sb">before the first test in it is run, and tear it down afterwards. Splitting up</span>
<span class="sb">the test case would require multiple set-up and tear-down processes, which is</span>
<span class="sb">inefficient and makes the semantics unclean.</span>

<span class="sb">If we were to determine the order of tests based on test name instead of test</span>
<span class="sb">case name, then we would have a problem with the following situation:</span>

<span class="sb">```c++</span>
<span class="sb">TEST_F(FooTest, AbcDeathTest) { ... }</span>
<span class="sb">TEST_F(FooTest, Uvw) { ... }</span>

<span class="sb">TEST_F(BarTest, DefDeathTest) { ... }</span>
<span class="sb">TEST_F(BarTest, Xyz) { ... }</span>
<span class="sb">```</span>

Since <span class="sb">`FooTest.AbcDeathTest`</span> needs to run before <span class="sb">`BarTest.Xyz`</span>, and we don&#39;t
interleave tests from different test suites, we need to run all tests in the
<span class="sb">`FooTest`</span> case before running any test in the <span class="sb">`BarTest`</span> case. This contradicts
with the requirement to run <span class="sb">`BarTest.DefDeathTest`</span> before <span class="sb">`FooTest.Uvw`</span>.

<span class="gu">## But I don&#39;t like calling my entire test suite `*DeathTest` when it contains both death tests and non-death tests. What do I do?</span>

You don&#39;t have to, but if you like, you may split up the test suite into
<span class="sb">`FooTest`</span> and <span class="sb">`FooDeathTest`</span>, where the names make it clear that they are
related:

```c++
class FooTest : public ::testing::Test { ... };

TEST_F(FooTest, Abc) { ... }
TEST_F(FooTest, Def) { ... }

using FooDeathTest = FooTest;

TEST_F(FooDeathTest, Uvw) { ... EXPECT_DEATH(...) ... }
TEST_F(FooDeathTest, Xyz) { ... ASSERT_DEATH(...) ... }
<span class="sb">```</span>

<span class="sb">## GoogleTest prints the LOG messages in a death test&#39;s child process only when the test fails. How can I see the LOG messages when the death test succeeds?</span>

<span class="sb">Printing the LOG messages generated by the statement inside `EXPECT_DEATH()`</span>
<span class="sb">makes it harder to search for real problems in the parent&#39;s log. Therefore,</span>
<span class="sb">GoogleTest only prints them when the death test has failed.</span>

<span class="sb">If you really need to see such LOG messages, a workaround is to temporarily</span>
<span class="sb">break the death test (e.g. by changing the regex pattern it is expected to</span>
<span class="sb">match). Admittedly, this is a hack. We&#39;ll consider a more permanent solution</span>
<span class="sb">after the fork-and-exec-style death tests are implemented.</span>

<span class="sb">## The compiler complains about `no match for &#39;operator&lt;&lt;&#39;` when I use an assertion. What gives?</span>

<span class="sb">If you use a user-defined type `FooType` in an assertion, you must make sure</span>
<span class="sb">there is an `std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const FooType&amp;)` function</span>
<span class="sb">defined such that we can print a value of `FooType`.</span>

<span class="sb">In addition, if `FooType` is declared in a name space, the `&lt;&lt;` operator also</span>
<span class="sb">needs to be defined in the *same* name space. See</span>
<span class="sb">[Tip of the Week #49](https://abseil.io/tips/49) for details.</span>

<span class="sb">## How do I suppress the memory leak messages on Windows?</span>

<span class="sb">Since the statically initialized GoogleTest singleton requires allocations on</span>
<span class="sb">the heap, the Visual C++ memory leak detector will report memory leaks at the</span>
<span class="sb">end of the program run. The easiest way to avoid this is to use the</span>
<span class="sb">`_CrtMemCheckpoint` and `_CrtMemDumpAllObjectsSince` calls to not report any</span>
<span class="sb">statically initialized heap objects. See MSDN for more details and additional</span>
<span class="sb">heap check/debug routines.</span>

<span class="sb">## How can my code detect if it is running in a test?</span>

<span class="sb">If you write code that sniffs whether it&#39;s running in a test and does different</span>
<span class="sb">things accordingly, you are leaking test-only logic into production code and</span>
<span class="sb">there is no easy way to ensure that the test-only code paths aren&#39;t run by</span>
<span class="sb">mistake in production. Such cleverness also leads to</span>
<span class="sb">[Heisenbugs](https://en.wikipedia.org/wiki/Heisenbug). Therefore we strongly</span>
<span class="sb">advise against the practice, and GoogleTest doesn&#39;t provide a way to do it.</span>

<span class="sb">In general, the recommended way to cause the code to behave differently under</span>
<span class="sb">test is [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection). You can inject</span>
<span class="sb">different functionality from the test and from the production code. Since your</span>
<span class="sb">production code doesn&#39;t link in the for-test logic at all (the</span>
<span class="sb">[`testonly`](https://docs.bazel.build/versions/master/be/common-definitions.html#common.testonly) attribute for BUILD targets helps to ensure</span>
<span class="sb">that), there is no danger in accidentally running it.</span>

<span class="sb">However, if you *really*, *really*, *really* have no choice, and if you follow</span>
<span class="sb">the rule of ending your test program names with `_test`, you can use the</span>
<span class="sb">*horrible* hack of sniffing your executable name (`argv[0]` in `main()`) to know</span>
<span class="sb">whether the code is under test.</span>

<span class="sb">## How do I temporarily disable a test?</span>

<span class="sb">If you have a broken test that you cannot fix right away, you can add the</span>
<span class="sb">`DISABLED_` prefix to its name. This will exclude it from execution. This is</span>
<span class="sb">better than commenting out the code or using `#if 0`, as disabled tests are</span>
<span class="sb">still compiled (and thus won&#39;t rot).</span>

<span class="sb">To include disabled tests in test execution, just invoke the test program with</span>
<span class="sb">the `--gtest_also_run_disabled_tests` flag.</span>

<span class="sb">## Is it OK if I have two separate `TEST(Foo, Bar)` test methods defined in different namespaces?</span>

<span class="sb">Yes.</span>

<span class="sb">The rule is **all test methods in the same test suite must use the same fixture</span>
<span class="sb">class**. This means that the following is **allowed** because both tests use the</span>
<span class="sb">same fixture class (`::testing::Test`).</span>

<span class="sb">```c++</span>
<span class="sb">namespace foo {</span>
<span class="sb">TEST(CoolTest, DoSomething) {</span>
<span class="sb">  SUCCEED();</span>
<span class="sb">}</span>
<span class="sb">}  // namespace foo</span>

<span class="sb">namespace bar {</span>
<span class="sb">TEST(CoolTest, DoSomething) {</span>
<span class="sb">  SUCCEED();</span>
<span class="sb">}</span>
<span class="sb">}  // namespace bar</span>
<span class="sb">```</span>

However, the following code is <span class="gs">**not allowed**</span> and will produce a runtime error
from GoogleTest because the test methods are using different test fixture
classes with the same test suite name.

```c++
namespace foo {
class CoolTest : public ::testing::Test {};  // Fixture foo::CoolTest
TEST_F(CoolTest, DoSomething) {
  SUCCEED();
}
}  // namespace foo

namespace bar {
class CoolTest : public ::testing::Test {};  // Fixture: bar::CoolTest
TEST_F(CoolTest, DoSomething) {
  SUCCEED();
}
}  // namespace bar
```
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2024, Wageningen University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #D0F1C6; */
    }
    /* Sidebar */
    .wy-nav-side {
      /* background: #ff0000; */
    }
  </style>


</body>
</html>