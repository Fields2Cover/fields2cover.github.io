

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File primer.md &mdash; Fields2Cover latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../_static/code-tabs.css?v=1bc26e2f" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://fields2cover.github.io/api/program_listing_file_googletest_docs_primer.md.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/code-tabs.js?v=c983d12e"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo_fields2cover.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Fields2Cover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/migration_to_v2.html">Migration guide to version 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="f2c_library.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Fields2Cover</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File primer.md</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_googletest_docs_primer.md.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-primer-md">
<span id="program-listing-file-googletest-docs-primer-md"></span><h1>Program Listing for File primer.md<a class="headerlink" href="#program-listing-for-file-primer-md" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_googletest_docs_primer.md.html#file-googletest-docs-primer-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">googletest/docs/primer.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span><span class="gh"># GoogleTest Primer</span>

<span class="gu">## Introduction: Why GoogleTest?</span>

<span class="ge">*GoogleTest*</span> helps you write better C++ tests.

GoogleTest is a testing framework developed by the Testing Technology team with
Google&#39;s specific requirements and constraints in mind. Whether you work on
Linux, Windows, or a Mac, if you write C++ code, GoogleTest can help you. And it
supports <span class="ge">*any*</span> kind of tests, not just unit tests.

So what makes a good test, and how does GoogleTest fit in? We believe:

<span class="k">1.</span>  Tests should be <span class="ge">*independent*</span> and <span class="ge">*repeatable*</span>. It&#39;s a pain to debug a test
    that succeeds or fails as a result of other tests. GoogleTest isolates the
    tests by running each of them on a different object. When a test fails,
    GoogleTest allows you to run it in isolation for quick debugging.
<span class="k">2.</span>  Tests should be well <span class="ge">*organized*</span> and reflect the structure of the tested
    code. GoogleTest groups related tests into test suites that can share data
    and subroutines. This common pattern is easy to recognize and makes tests
    easy to maintain. Such consistency is especially helpful when people switch
    projects and start to work on a new code base.
<span class="k">3.</span>  Tests should be <span class="ge">*portable*</span> and <span class="ge">*reusable*</span>. Google has a lot of code that is
    platform-neutral; its tests should also be platform-neutral. GoogleTest
    works on different OSes, with different compilers, with or without
    exceptions, so GoogleTest tests can work with a variety of configurations.
<span class="k">4.</span>  When tests fail, they should provide as much <span class="ge">*information*</span> about the problem
    as possible. GoogleTest doesn&#39;t stop at the first test failure. Instead, it
    only stops the current test and continues with the next. You can also set up
    tests that report non-fatal failures after which the current test continues.
    Thus, you can detect and fix multiple bugs in a single run-edit-compile
    cycle.
<span class="k">5.</span>  The testing framework should liberate test writers from housekeeping chores
    and let them focus on the test <span class="ge">*content*</span>. GoogleTest automatically keeps
    track of all tests defined, and doesn&#39;t require the user to enumerate them
    in order to run them.
<span class="k">6.</span>  Tests should be <span class="ge">*fast*</span>. With GoogleTest, you can reuse shared resources
    across tests and pay for the set-up/tear-down only once, without making
    tests depend on each other.

Since GoogleTest is based on the popular xUnit architecture, you&#39;ll feel right
at home if you&#39;ve used JUnit or PyUnit before. If not, it will take you about 10
minutes to learn the basics and get started. So let&#39;s go!

<span class="gu">## Beware of the Nomenclature</span>

{: .callout .note}
<span class="ge">*Note:*</span> There might be some confusion arising from different definitions of the
terms <span class="ge">*Test*</span>, <span class="ge">*Test Case*</span> and <span class="ge">*Test Suite*</span>, so beware of misunderstanding these.

Historically, GoogleTest started to use the term <span class="ge">*Test Case*</span> for grouping
related tests, whereas current publications, including International Software
Testing Qualifications Board ([ISTQB](https://www.istqb.org/)) materials and
various textbooks on software quality, use the term
<span class="ge">*[Test Suite][istqb test suite]*</span> for this.

The related term <span class="ge">*Test*</span>, as it is used in GoogleTest, corresponds to the term
<span class="ge">*[Test Case][istqb test case]*</span> of ISTQB and others.

The term <span class="ge">*Test*</span> is commonly of broad enough sense, including ISTQB&#39;s definition
of <span class="ge">*Test Case*</span>, so it&#39;s not much of a problem here. But the term <span class="ge">*Test Case*</span> as
was used in Google Test is of contradictory sense and thus confusing.

GoogleTest recently started replacing the term <span class="ge">*Test Case*</span> with <span class="ge">*Test Suite*</span>.
The preferred API is <span class="ge">*TestSuite*</span>. The older TestCase API is being slowly
deprecated and refactored away.

So please be aware of the different definitions of the terms:


Meaning                                                                              | GoogleTest Term         | [<span class="nt">ISTQB</span>](<span class="na">https://www.istqb.org/</span>) Term
:----------------------------------------------------------------------------------- | :---------------------- | :----------------------------------
Exercise a particular program path with specific input values and verify the results | [<span class="nt">TEST()</span>](<span class="na">#simple-tests</span>) | [<span class="nt">Test Case</span>][<span class="nl">istqb test case</span>]


[<span class="nl">istqb test case</span>]: <span class="na">https://glossary.istqb.org/en_US/term/test-case</span>
[<span class="nl">istqb test suite</span>]: <span class="na">https://glossary.istqb.org/en_US/term/test-suite</span>

<span class="gu">## Basic Concepts</span>

When using GoogleTest, you start by writing <span class="ge">*assertions*</span>, which are statements
that check whether a condition is true. An assertion&#39;s result can be <span class="ge">*success*</span>,
<span class="ge">*nonfatal failure*</span>, or <span class="ge">*fatal failure*</span>. If a fatal failure occurs, it aborts the
current function; otherwise the program continues normally.

<span class="ge">*Tests*</span> use assertions to verify the tested code&#39;s behavior. If a test crashes
or has a failed assertion, then it <span class="ge">*fails*</span>; otherwise it <span class="ge">*succeeds*</span>.

A <span class="ge">*test suite*</span> contains one or many tests. You should group your tests into test
suites that reflect the structure of the tested code. When multiple tests in a
test suite need to share common objects and subroutines, you can put them into a
<span class="ge">*test fixture*</span> class.

A <span class="ge">*test program*</span> can contain multiple test suites.

We&#39;ll now explain how to write a test program, starting at the individual
assertion level and building up to tests and test suites.

<span class="gu">## Assertions</span>

GoogleTest assertions are macros that resemble function calls. You test a class
or function by making assertions about its behavior. When an assertion fails,
GoogleTest prints the assertion&#39;s source file and line number location, along
with a failure message. You may also supply a custom failure message which will
be appended to GoogleTest&#39;s message.

The assertions come in pairs that test the same thing but have different effects
on the current function. <span class="sb">`ASSERT_*`</span> versions generate fatal failures when they
fail, and <span class="gs">**abort the current function**</span>. <span class="sb">`EXPECT_*`</span> versions generate nonfatal
failures, which don&#39;t abort the current function. Usually <span class="sb">`EXPECT_*`</span> are
preferred, as they allow more than one failure to be reported in a test.
However, you should use <span class="sb">`ASSERT_*`</span> if it doesn&#39;t make sense to continue when the
assertion in question fails.

Since a failed <span class="sb">`ASSERT_*`</span> returns from the current function immediately,
possibly skipping clean-up code that comes after it, it may cause a space leak.
Depending on the nature of the leak, it may or may not be worth fixing - so keep
this in mind if you get a heap checker error in addition to assertion errors.

To provide a custom failure message, simply stream it into the macro using the
<span class="sb">`&lt;&lt;`</span> operator or a sequence of such operators. See the following example, using
the [<span class="sb">`ASSERT_EQ`</span> and <span class="sb">`EXPECT_EQ`</span>](reference/assertions.md#EXPECT_EQ) macros to
verify value equality:

```c++
ASSERT_EQ(x.size(), y.size()) &lt;&lt; &quot;Vectors x and y are of unequal length&quot;;

for (int i = 0; i &lt; x.size(); ++i) {
  EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;Vectors x and y differ at index &quot; &lt;&lt; i;
}
<span class="sb">```</span>

<span class="sb">Anything that can be streamed to an `ostream` can be streamed to an assertion</span>
<span class="sb">macro--in particular, C strings and `string` objects. If a wide string</span>
<span class="sb">(`wchar_t*`, `TCHAR*` in `UNICODE` mode on Windows, or `std::wstring`) is</span>
<span class="sb">streamed to an assertion, it will be translated to UTF-8 when printed.</span>

<span class="sb">GoogleTest provides a collection of assertions for verifying the behavior of</span>
<span class="sb">your code in various ways. You can check Boolean conditions, compare values</span>
<span class="sb">based on relational operators, verify string values, floating-point values, and</span>
<span class="sb">much more. There are even assertions that enable you to verify more complex</span>
<span class="sb">states by providing custom predicates. For the complete list of assertions</span>
<span class="sb">provided by GoogleTest, see the [Assertions Reference](reference/assertions.md).</span>

<span class="sb">## Simple Tests</span>

<span class="sb">To create a test:</span>

<span class="sb">1.  Use the `TEST()` macro to define and name a test function. These are</span>
<span class="sb">    ordinary C++ functions that don&#39;t return a value.</span>
<span class="sb">2.  In this function, along with any valid C++ statements you want to include,</span>
<span class="sb">    use the various GoogleTest assertions to check values.</span>
<span class="sb">3.  The test&#39;s result is determined by the assertions; if any assertion in the</span>
<span class="sb">    test fails (either fatally or non-fatally), or if the test crashes, the</span>
<span class="sb">    entire test fails. Otherwise, it succeeds.</span>

<span class="sb">```c++</span>
<span class="sb">TEST(TestSuiteName, TestName) {</span>
<span class="sb">  ... test body ...</span>
<span class="sb">}</span>
<span class="sb">```</span>

<span class="sb">`TEST()`</span> arguments go from general to specific. The <span class="ge">*first*</span> argument is the name
of the test suite, and the <span class="ge">*second*</span> argument is the test&#39;s name within the test
suite. Both names must be valid C++ identifiers, and they should not contain any
underscores (<span class="sb">`_`</span>). A test&#39;s <span class="ge">*full name*</span> consists of its containing test suite
and its individual name. Tests from different test suites can have the same
individual name.

For example, let&#39;s take a simple integer function:

```c++
int Factorial(int n);  // Returns the factorial of n
<span class="sb">```</span>

<span class="sb">A test suite for this function might look like:</span>

<span class="sb">```c++</span>
<span class="sb">// Tests factorial of 0.</span>
<span class="sb">TEST(FactorialTest, HandlesZeroInput) {</span>
<span class="sb">  EXPECT_EQ(Factorial(0), 1);</span>
<span class="sb">}</span>

<span class="sb">// Tests factorial of positive numbers.</span>
<span class="sb">TEST(FactorialTest, HandlesPositiveInput) {</span>
<span class="sb">  EXPECT_EQ(Factorial(1), 1);</span>
<span class="sb">  EXPECT_EQ(Factorial(2), 2);</span>
<span class="sb">  EXPECT_EQ(Factorial(3), 6);</span>
<span class="sb">  EXPECT_EQ(Factorial(8), 40320);</span>
<span class="sb">}</span>
<span class="sb">```</span>

GoogleTest groups the test results by test suites, so logically related tests
should be in the same test suite; in other words, the first argument to their
<span class="sb">`TEST()`</span> should be the same. In the above example, we have two tests,
<span class="sb">`HandlesZeroInput`</span> and <span class="sb">`HandlesPositiveInput`</span>, that belong to the same test
suite <span class="sb">`FactorialTest`</span>.

When naming your test suites and tests, you should follow the same convention as
for
[<span class="nt">naming functions and classes</span>](<span class="na">https://google.github.io/styleguide/cppguide.html#Function_Names</span>).

<span class="gs">**Availability**</span>: Linux, Windows, Mac.

<span class="gu">## Test Fixtures: Using the Same Data Configuration for Multiple Tests {#same-data-multiple-tests}</span>

If you find yourself writing two or more tests that operate on similar data, you
can use a <span class="ge">*test fixture*</span>. This allows you to reuse the same configuration of
objects for several different tests.

To create a fixture:

<span class="k">1.</span>  Derive a class from <span class="sb">`testing::Test`</span> . Start its body with <span class="sb">`protected:`</span>, as
    we&#39;ll want to access fixture members from sub-classes.
<span class="k">2.</span>  Inside the class, declare any objects you plan to use.
<span class="k">3.</span>  If necessary, write a default constructor or <span class="sb">`SetUp()`</span> function to prepare
    the objects for each test. A common mistake is to spell <span class="sb">`SetUp()`</span> as
    <span class="gs">**`Setup()`**</span> with a small <span class="sb">`u`</span> - Use <span class="sb">`override`</span> in C++11 to make sure you
    spelled it correctly.
<span class="k">4.</span>  If necessary, write a destructor or <span class="sb">`TearDown()`</span> function to release any
    resources you allocated in <span class="sb">`SetUp()`</span> . To learn when you should use the
    constructor/destructor and when you should use <span class="sb">`SetUp()/TearDown()`</span>, read
    the [<span class="nt">FAQ</span>](<span class="na">faq.md#CtorVsSetUp</span>).
<span class="k">5.</span>  If needed, define subroutines for your tests to share.

When using a fixture, use <span class="sb">`TEST_F()`</span> instead of <span class="sb">`TEST()`</span> as it allows you to
access objects and subroutines in the test fixture:

```c++
TEST_F(TestFixtureClassName, TestName) {
  ... test body ...
}
<span class="sb">```</span>

<span class="sb">Unlike `TEST()`, in `TEST_F()` the first argument must be the name of the test</span>
<span class="sb">fixture class. (`_F` stands for &quot;Fixture&quot;). No test suite name is specified for</span>
<span class="sb">this macro.</span>

<span class="sb">Unfortunately, the C++ macro system does not allow us to create a single macro</span>
<span class="sb">that can handle both types of tests. Using the wrong macro causes a compiler</span>
<span class="sb">error.</span>

<span class="sb">Also, you must first define a test fixture class before using it in a</span>
<span class="sb">`TEST_F()`, or you&#39;ll get the compiler error &quot;`virtual outside class</span>
<span class="sb">declaration`&quot;.</span>

<span class="sb">For each test defined with `TEST_F()`, GoogleTest will create a *fresh* test</span>
<span class="sb">fixture at runtime, immediately initialize it via `SetUp()`, run the test, clean</span>
<span class="sb">up by calling `TearDown()`, and then delete the test fixture. Note that</span>
<span class="sb">different tests in the same test suite have different test fixture objects, and</span>
<span class="sb">GoogleTest always deletes a test fixture before it creates the next one.</span>
<span class="sb">GoogleTest does **not** reuse the same test fixture for multiple tests. Any</span>
<span class="sb">changes one test makes to the fixture do not affect other tests.</span>

<span class="sb">As an example, let&#39;s write tests for a FIFO queue class named `Queue`, which has</span>
<span class="sb">the following interface:</span>

<span class="sb">```c++</span>
<span class="sb">template &lt;typename E&gt;  // E is the element type.</span>
<span class="sb">class Queue {</span>
<span class="sb"> public:</span>
<span class="sb">  Queue();</span>
<span class="sb">  void Enqueue(const E&amp; element);</span>
<span class="sb">  E* Dequeue();  // Returns NULL if the queue is empty.</span>
<span class="sb">  size_t size() const;</span>
<span class="sb">  ...</span>
<span class="sb">};</span>
<span class="sb">```</span>

First, define a fixture class. By convention, you should give it the name
<span class="sb">`FooTest`</span> where <span class="sb">`Foo`</span> is the class being tested.

```c++
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
     // q0_ remains empty
     q1_.Enqueue(1);
     q2_.Enqueue(2);
     q2_.Enqueue(3);
  }

  // ~QueueTest() override = default;

  Queue&lt;int&gt; q0_;
  Queue&lt;int&gt; q1_;
  Queue&lt;int&gt; q2_;
};
<span class="sb">```</span>

<span class="sb">In this case, we don&#39;t need to define a destructor or a `TearDown()` method,</span>
<span class="sb">because the implicit destructor generated by the compiler will perform all of</span>
<span class="sb">the necessary cleanup.</span>

<span class="sb">Now we&#39;ll write tests using `TEST_F()` and this fixture.</span>

<span class="sb">```c++</span>
<span class="sb">TEST_F(QueueTest, IsEmptyInitially) {</span>
<span class="sb">  EXPECT_EQ(q0_.size(), 0);</span>
<span class="sb">}</span>

<span class="sb">TEST_F(QueueTest, DequeueWorks) {</span>
<span class="sb">  int* n = q0_.Dequeue();</span>
<span class="sb">  EXPECT_EQ(n, nullptr);</span>

<span class="sb">  n = q1_.Dequeue();</span>
<span class="sb">  ASSERT_NE(n, nullptr);</span>
<span class="sb">  EXPECT_EQ(*n, 1);</span>
<span class="sb">  EXPECT_EQ(q1_.size(), 0);</span>
<span class="sb">  delete n;</span>

<span class="sb">  n = q2_.Dequeue();</span>
<span class="sb">  ASSERT_NE(n, nullptr);</span>
<span class="sb">  EXPECT_EQ(*n, 2);</span>
<span class="sb">  EXPECT_EQ(q2_.size(), 1);</span>
<span class="sb">  delete n;</span>
<span class="sb">}</span>
<span class="sb">```</span>

The above uses both <span class="sb">`ASSERT_*`</span> and <span class="sb">`EXPECT_*`</span> assertions. The rule of thumb is
to use <span class="sb">`EXPECT_*`</span> when you want the test to continue to reveal more errors after
the assertion failure, and use <span class="sb">`ASSERT_*`</span> when continuing after failure doesn&#39;t
make sense. For example, the second assertion in the <span class="sb">`Dequeue`</span> test is
<span class="sb">`ASSERT_NE(n, nullptr)`</span>, as we need to dereference the pointer <span class="sb">`n`</span> later, which
would lead to a segfault when <span class="sb">`n`</span> is <span class="sb">`NULL`</span>.

When these tests run, the following happens:

<span class="k">1.</span>  GoogleTest constructs a <span class="sb">`QueueTest`</span> object (let&#39;s call it <span class="sb">`t1`</span>).
<span class="k">2.</span>  The first test (<span class="sb">`IsEmptyInitially`</span>) runs on <span class="sb">`t1`</span>.
<span class="k">3.</span>  <span class="sb">`t1`</span> is destructed.
<span class="k">4.</span>  The above steps are repeated on another <span class="sb">`QueueTest`</span> object, this time
    running the <span class="sb">`DequeueWorks`</span> test.

<span class="gs">**Availability**</span>: Linux, Windows, Mac.

<span class="gu">## Invoking the Tests</span>

<span class="sb">`TEST()`</span> and <span class="sb">`TEST_F()`</span> implicitly register their tests with GoogleTest. So,
unlike with many other C++ testing frameworks, you don&#39;t have to re-list all
your defined tests in order to run them.

After defining your tests, you can run them with <span class="sb">`RUN_ALL_TESTS()`</span>, which
returns <span class="sb">`0`</span> if all the tests are successful, or <span class="sb">`1`</span> otherwise. Note that
<span class="sb">`RUN_ALL_TESTS()`</span> runs <span class="ge">*all tests*</span> in your link unit--they can be from different
test suites, or even different source files.

When invoked, the <span class="sb">`RUN_ALL_TESTS()`</span> macro:

<span class="k">*</span><span class="w"> </span>  Saves the state of all GoogleTest flags.

<span class="k">*</span><span class="w"> </span>  Creates a test fixture object for the first test.

<span class="k">*</span><span class="w"> </span>  Initializes it via <span class="sb">`SetUp()`</span>.

<span class="k">*</span><span class="w"> </span>  Runs the test on the fixture object.

<span class="k">*</span><span class="w"> </span>  Cleans up the fixture via <span class="sb">`TearDown()`</span>.

<span class="k">*</span><span class="w"> </span>  Deletes the fixture.

<span class="k">*</span><span class="w"> </span>  Restores the state of all GoogleTest flags.

<span class="k">*</span><span class="w"> </span>  Repeats the above steps for the next test, until all tests have run.

If a fatal failure happens the subsequent steps will be skipped.

{: .callout .important}
<span class="k">&gt; </span><span class="ge">IMPORTANT: You must **not** ignore the return value of `RUN_ALL_TESTS()`, or</span>
<span class="k">&gt; </span><span class="ge">you will get a compiler error. The rationale for this design is that the</span>
<span class="k">&gt; </span><span class="ge">automated testing service determines whether a test has passed based on its</span>
<span class="k">&gt; </span><span class="ge">exit code, not on its stdout/stderr output; thus your `main()` function must</span>
<span class="k">&gt; </span><span class="ge">return the value of `RUN_ALL_TESTS()`.</span>
<span class="k">&gt;</span>
<span class="ge">&gt; Also, you should call `RUN_ALL_TESTS()` only **once**. Calling it more than</span>
<span class="k">&gt; </span><span class="ge">once conflicts with some advanced GoogleTest features (e.g., thread-safe</span>
<span class="k">&gt; </span><span class="ge">[death tests](advanced.md#death-tests)) and thus is not supported.</span>

<span class="gs">**Availability**</span>: Linux, Windows, Mac.

<span class="gu">## Writing the main() Function</span>

Most users should <span class="ge">*not*</span> need to write their own <span class="sb">`main`</span> function and instead link
with <span class="sb">`gtest_main`</span> (as opposed to with <span class="sb">`gtest`</span>), which defines a suitable entry
point. See the end of this section for details. The remainder of this section
should only apply when you need to do something custom before the tests run that
cannot be expressed within the framework of fixtures and test suites.

If you write your own <span class="sb">`main`</span> function, it should return the value of
<span class="sb">`RUN_ALL_TESTS()`</span>.

You can start from this boilerplate:

```c++
<span class="gh">#include &quot;this/package/foo.h&quot;</span>

<span class="gh">#include &lt;gtest/gtest.h&gt;</span>

namespace my {
namespace project {
namespace {

// The fixture for testing class Foo.
class FooTest : public testing::Test {
 protected:
  // You can remove any or all of the following functions if their bodies would
  // be empty.

  FooTest() {
     // You can do set-up work for each test here.
  }

  ~FooTest() override {
     // You can do clean-up work that doesn&#39;t throw exceptions here.
  }

  // If the constructor and destructor are not enough for setting up
  // and cleaning up each test, you can define the following methods:

  void SetUp() override {
     // Code here will be called immediately after the constructor (right
     // before each test).
  }

  void TearDown() override {
     // Code here will be called immediately after each test (right
     // before the destructor).
  }

  // Class members declared here can be used by all tests in the test suite
  // for Foo.
};

// Tests that the Foo::Bar() method does Abc.
TEST_F(FooTest, MethodBarDoesAbc) {
  const std::string input_filepath = &quot;this/package/testdata/myinputfile.dat&quot;;
  const std::string output_filepath = &quot;this/package/testdata/myoutputfile.dat&quot;;
  Foo f;
  EXPECT_EQ(f.Bar(input_filepath, output_filepath), 0);
}

// Tests that Foo does Xyz.
TEST_F(FooTest, DoesXyz) {
  // Exercises the Xyz feature of Foo.
}

}  // namespace
}  // namespace project
}  // namespace my

int main(int argc, char **argv) {
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
```

The <span class="sb">`testing::InitGoogleTest()`</span> function parses the command line for GoogleTest
flags, and removes all recognized flags. This allows the user to control a test
program&#39;s behavior via various flags, which we&#39;ll cover in the
[<span class="nt">AdvancedGuide</span>](<span class="na">advanced.md</span>). You <span class="gs">**must**</span> call this function before calling
<span class="sb">`RUN_ALL_TESTS()`</span>, or the flags won&#39;t be properly initialized.

On Windows, <span class="sb">`InitGoogleTest()`</span> also works with wide strings, so it can be used
in programs compiled in <span class="sb">`UNICODE`</span> mode as well.

But maybe you think that writing all those <span class="sb">`main`</span> functions is too much work? We
agree with you completely, and that&#39;s why Google Test provides a basic
implementation of main(). If it fits your needs, then just link your test with
the <span class="sb">`gtest_main`</span> library and you are good to go.

{: .callout .note}
NOTE: <span class="sb">`ParseGUnitFlags()`</span> is deprecated in favor of <span class="sb">`InitGoogleTest()`</span>.

<span class="gu">## Known Limitations</span>

<span class="k">*</span><span class="w"> </span>  Google Test is designed to be thread-safe. The implementation is thread-safe
    on systems where the <span class="sb">`pthreads`</span> library is available. It is currently
    <span class="ge">*unsafe*</span> to use Google Test assertions from two threads concurrently on
    other systems (e.g. Windows). In most tests this is not an issue as usually
    the assertions are done in the main thread. If you want to help, you can
    volunteer to implement the necessary synchronization primitives in
    <span class="sb">`gtest-port.h`</span> for your platform.
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2024, Wageningen University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #D0F1C6; */
    }
    /* Sidebar */
    .wy-nav-side {
      /* background: #ff0000; */
    }
  </style>


</body>
</html>